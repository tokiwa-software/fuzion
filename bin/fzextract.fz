# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of fzextract
#
# -----------------------------------------------------------------------

#
# fzextract can be used to extract
# fuzion native feature definitions from
# c header files. Use it like this:
#
# fz -modules=clang fzextract.fz some_header_file.h
#

string_option : option String is
  public redef as_string String =>
    match string_option.this
      nil => "*** unknown type ***"
      s String => s

# map a type from the C code to a fuzion type
#
to_fuzion_type(ct String, is_result_type bool) string_option =>

  # remove any type qualifiers
  c_type := ct
    .replace "const " ""
    .replace "volatile " ""
    .replace "restrict " ""
    .replace "*const" "*"
    .replace "*volatile" "*"
    .replace "*restrict" "*"
    # NYI: UNDER DEVELOPMENT: C11?
    # .replace "_Thread_local"
    # .replace "_Atomic"

  if c_type = "void"
    "unit"
  else if c_type.contains "*" || c_type.ends_with "]"
    if is_result_type
      # NYI: UNDER DEVELOPMENT: support for more complex result types?
      "Native_Ref /* from: {c_type} */"
    else if c_type = "unsigned char *" || c_type = "uint8_t *" || c_type.starts_with "unsigned char["
      "mutate.array u8"
    else if c_type = "char *" || c_type.starts_with "char["
      "mutate.array i8"
    else if c_type = "unsigned long long *"
      "mutate.array u64"
    else if c_type = "double *" || c_type.starts_with "double["
      "mutate.array f64"
    else if c_type = "size_t *" || c_type = "long *"
      "mutate.array i64"
    else if c_type = "FILE *"
      "Native_Ref"
    else if c_type = "int *" || c_type = "int32_t *"
      "mutate.array i32"
    else if c_type = "unsigned int *"
      "mutate.array u32"
    else if c_type = "unsigned short *" || c_type.starts_with "unsigned short["
      "mutate.array u16"
    else
      "Native_Ref /* from: {c_type} */"
  else if c_type = "float"
    "f32"
  else if c_type = "double"
    "f64"
  else if c_type = "int64_t"
    "i64"
  else if c_type = "int32_t" || c_type = "int"
    "i32"
  else if c_type = "uint64_t" || c_type = "unsigned long long"
    "u64"
  else if c_type = "int8_t"
    "i8"
  else if c_type = "uint8_t" || c_type = "unsigned char"
    "u8"
  else if c_type = "size_t" || c_type = "long"
    "i64"
  else if c_type = "uint32_t"
    "u32"
  else
    # NYI: UNDER DEVELOPMENT: we could support more complex types
    nil


# via `java --class-path=build/classes dev.flang.parser.Lexer -keywords`
#
keywords := container.set_of_ordered ["abstract", "check", "const", "do", "else", "env", "fixed", "for", "if", "in", "index", "infix", "infix_right", "intrinsic", "inv", "is", "leaf", "loop", "match", "module", "native", "post", "postfix", "pre", "prefix", "private", "public", "redef", "ref", "set", "ternary", "then", "this", "type", "universe", "until", "var", "variant", "while"]

# map an arg name from the C code to a fuzion name
#
to_fuzion_name(str String) =>
  if keywords ∋ str
    str + "_"
  else if str.is_blank
    "_"
  else
    str

#########

if envir.args.count != 2
  say "usage: "
  say "fz -modules=clang fzextract.fz some_header_file.h"
  exit 1

say """
  #
  # autogenerated by fzextract.fz from {envir.args[1]}
  #

  module c is
  """

lines := mut (container.expanding_array String).empty

match {
  clang.parse_header envir.args[1] f_decl->
    valid := (f_decl.args ∀ (arg -> !(to_fuzion_type arg.arg_type false).is_nil)) && !(to_fuzion_type f_decl.return_type true).is_nil
    args_str := f_decl
      .args
      .map arg->
        "{to_fuzion_name arg.name} {to_fuzion_type arg.arg_type false}"
      .as_string ", "
    lines <- lines.add "  {if valid then "" else "# "}module {f_decl.name}{if args_str.is_empty then "" else "($args_str)"} {to_fuzion_type f_decl.return_type true} => native"
      }
  unit =>
    say <| (container.set_of_ordered lines.get).sort.as_string "\n"
  e error =>
    say e
    exit 1
