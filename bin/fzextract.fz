# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of fzextract
#
# -----------------------------------------------------------------------

#
# fzextract can be used to extract
# fuzion native feature definitions from
# c header files. Use it like this:
#
# fz -modules=clang fzextract.fz some_header_file.h
#

string_option : option String is
  public redef as_string String =>
    match string_option.this
      nil => "*** unknown type ***"
      s String => s

# map a type from the C code to a fuzion type
#
to_fuzion_type(ct String, is_result_type bool) string_option =>

  # remove any type qualifiers
  c_type := ct
    .replace "const " ""
    .replace "volatile " ""
    .replace "restrict " ""
    .replace "*const" "*"
    .replace "*volatile" "*"
    .replace "*restrict" "*"
    # NYI: UNDER DEVELOPMENT: C11?
    # .replace "_Thread_local"
    # .replace "_Atomic"

  if c_type = "void"
    "unit"
  else if c_type.contains "*" || c_type.ends_with "]"
    if is_result_type
      # NYI: UNDER DEVELOPMENT: support for more complex result types?
      "Native_Ref /* from: {c_type} */"
    else if c_type = "unsigned char *" || c_type = "uint8_t *" || c_type.starts_with "unsigned char["
      "mutate.array u8"
    else if c_type = "char *" || c_type.starts_with "char["
      "mutate.array i8"
    else if c_type = "unsigned long long *"
      "mutate.array u64"
    else if c_type = "double *" || c_type.starts_with "double["
      "mutate.array f64"
    else if c_type = "size_t *" || c_type = "long *" || c_type = "int64_t *"
      "mutate.array i64"
    else if c_type = "FILE *"
      "Native_Ref"
    else if c_type = "int *" || c_type = "int32_t *"
      "mutate.array i32"
    else if c_type = "unsigned int *"
      "mutate.array u32"
    else if c_type = "unsigned short *" || c_type.starts_with "unsigned short["
      "mutate.array u16"
    else
      "Native_Ref /* from: {c_type} */"
  else if c_type = "float"
    "f32"
  else if c_type = "double"
    "f64"
  else if c_type = "int64_t"
    "i64"
  else if c_type = "int32_t" || c_type = "int"
    "i32"
  else if c_type = "uint64_t" || c_type = "unsigned long long"
    "u64"
  else if c_type = "int8_t"
    "i8"
  else if c_type = "short"
    "i16"
  else if c_type = "unsigned short"
    "u16"
  else if c_type = "uint8_t" || c_type = "unsigned char"
    "u8"
  else if c_type = "size_t" || c_type = "long"
    "i64"
  else if c_type = "uint32_t" || c_type = "unsigned int"
    "u32"
  else if c_type.starts_with "enum "
    "u32 /* from: {c_type} */"
  else if known_structs.has c_type
    "c.{c_type}"
  else if known_enums.has c_type
    "i32 /* from enum {c_type} */"
  else
    # NYI: UNDER DEVELOPMENT: we could support more complex types
    nil


# via `java --class-path=build/classes dev.flang.parser.Lexer -keywords`
#
keywords := container.set_of_ordered ["abstract", "check", "const", "do", "else", "env", "fixed", "for", "if", "in", "index", "infix", "infix_right", "intrinsic", "inv", "is", "leaf", "loop", "match", "module", "native", "post", "postfix", "pre", "prefix", "private", "public", "redef", "ref", "set", "ternary", "then", "this", "type", "universe", "until", "var", "variant", "while",
    # manually added:
    "result"]

# map an arg name from the C code to a fuzion name
#
to_fuzion_name(str String) =>
  if keywords ∋ str
    str + "_"
  else if str.is_blank
    "_"
  else
    str

#########

if envir.args.count != 2
  say "usage: "
  say "fz -modules=clang fzextract.fz some_header_file.h"
  exit 1

say """
  #
  # autogenerated by fzextract.fz from {envir.args[1]}
  #

  module c is
  """

function_declarations := mut (container.expanding_array String).empty

# NYI: CLEANUP: use local mutate
_ := mutate

# store known structs
#
known_structs := container.mutable_tree_map mutate String clang.struct_decl .empty

# store known enums
#
known_enums := container.mutable_tree_map mutate String clang.enum_decl .empty

match {
  clang.parse_header envir.args[1] c->
    match c
      f_decl clang.function_decl =>
        valid := (f_decl.args ∀ (arg -> !(to_fuzion_type arg.arg_type false).is_nil)) && !(to_fuzion_type f_decl.return_type true).is_nil
        args_str := f_decl
          .args
          .map arg->
            "{to_fuzion_name arg.name} {to_fuzion_type arg.arg_type false}"
          .as_string ", "
        function_declarations <- function_declarations.add "  {if valid then "" else "# "}module {f_decl.name}{if args_str.is_empty then "" else "($args_str)"} {to_fuzion_type f_decl.return_type true} => native"
      s_decl clang.struct_decl =>
        if (s_decl.fields ∀ (field -> !(to_fuzion_type field.arg_type false).is_nil))
          known_structs.put s_decl.name s_decl
      clang.union_decl =>
      e_decl clang.enum_decl =>
        known_enums.put e_decl.name e_decl
      }

  unit =>

    say """
      {" structs ".pad_center "#" 80}
      """

    # NYI: BUG: we need to add padding
    # NYI: BUG: we need to evaluate arrays properly
    #   module CXType(module kind u32 /* from: enum CXTypeKind */, module data Native_Ref /* from: void *[2] */) is
    # should be sth. like:
    #   CXType(kind i32 /*type_kind*/, padding i32, data1, data2 Native_Ref) is


    known_structs.values.for_each s_decl->
      say <| "  module {s_decl.name}({s_decl.fields.map (f -> "module {to_fuzion_name f.name} {to_fuzion_type f.arg_type false}") .as_string ", "}) is"

    say ""

    say """
      {" function declarations ".pad_center "#" 80}
      """

    say <| (container.set_of_ordered function_declarations.get).sort.as_string "\n"

  e error =>
    say e
    exit 1
