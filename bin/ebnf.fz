# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  source code of script ebnf.fz
#
# -----------------------------------------------------------------------

# echos ebnf grammar and tests the resulting grammar with antlr
# 1) Extract ebnf grammar from Lexer/Parser.java
# 2) Test if grammar can be parsed with antlr4

main =>

  ########### Extensions ###############

  # execute this Sequence of process+args
  # return what we read from stdout as the result
  #
  Sequence.prefix ! String =>

    lm : mutate is

    lm ! ()->
      seq := map x->x.as_string
      match os.process.start seq.first.val (seq.drop 1)
        e error => panic "failed executing {Sequence.this}, error is $e"
        p os.process =>
          res :=
            match p.with_out String lm (()->String.from_bytes (io.buffered lm).read_fully)
              e error => panic "failed reading stdout from {Sequence.this}, error is: $e"
              s String => s.trim_end
          err :=
            match p.with_err String lm (()->String.from_bytes (io.buffered lm).read_fully)
              e error => panic "failed reading stderr from {Sequence.this}, error is: $e"
              s String => s.trim_end
          ec := p.wait.get 1
          if ec != 0
            panic "error $ec when executing $seq, stderr: $err"
          res


  # feed this string to a new process
  # return what we read from stdout as the result
  #
  String.infix | (seq Sequence String) String =>

    lm : mutate is

    lm ! ()->
      match os.process.start seq.first.val (seq.drop 1)
        e error => panic "failed executing $seq, error is $e"
        p os.process =>
          _ := p.with_in unit lm ()->
            _ := (io.buffered lm).writer.env.write String.this.utf8
            _ := (io.buffered lm).writer.env.flush
            _ := p.wait # close stdin
          match p.with_out String lm (()->String.from_bytes (io.buffered lm).read_fully)
            e error => panic "failed reading stdout from $seq, error is: $e"
            s String => s


  # execute this string by splitting at all whitespaces
  # return what we read from stdout as the result
  #
  String.prefix !! String =>
    !split


  # check if exe is installed by trying
  # to execute it once
  #
  is_installed(exe String) =>
    (os.process.start exe).ok


  ########### EBNF ###############

  if !(is_installed "antlr" || is_installed "antlr4")
    io.err.println "not generating ebnf due to missing dependency antlr"
    exit 0
  else
    new_line := "\n"

    if envir.args.count < 2
      panic "expecting at least one file name argument"

    # header
    ebnf_header := "grammar Fuzion;$new_line$new_line"

    ebnf := envir.args.drop 1
      .map src->
        if !io.file.exists src
          panic "file not found '$src'."


        # read src file
        src_lines :=
          io.file.use _ src io.file.mode.read ()->
            (io.buffered io.file.file_mutate).read_lines

        # first, strip out asciidoc code that is enclosed as blocks of the form
        #
        #   // tag::bla_bla
        #   ...
        #   // end::bla_bla
        #
        src_without_asciidoc :=
          for
              res Sequence String := [], new_res # source without asciidoc comments
              in_asciidoc bool := false, new_in_asciidoc
              l in src_lines.ok ? src_lines.val : []
          do
            new_res, new_in_asciidoc :=
              if in_asciidoc || l.trim.starts_with "// tag::"
                (res, !l.trim.starts_with "// end::")
              else
                (res ++ [l], false)
          else
            res


        # helper feature to determine the start of an EBNF rule
        starts_rule(s String) =>
          parts := s.split ":"
          rule := parts[0].trim
          (!s.starts_with " " && parts.count >= 2 && !rule.contains " "
           && !rule.is_empty && (rule.as_codepoints âˆ€ c->c.is_ascii_alpha_num || c = "_"))


        # then, extract EBNF rules of the form
        #
        # bla_bla : rhs
        #         | rhs
        #         ;
        #
        # or
        #
        # fragment
        # bla_bla : rhs
        #         | rhs
        #         ;
        #
        ebnf_rules :=
          for
            res Sequence String := [], new_res # the extracted EBNF rules
            in_rule bool := false, new_in_rule
            l in src_without_asciidoc
          do
            new_res, new_in_rule :=
              if in_rule || l = "fragment" || starts_rule l
                (res ++ [l], !l.ends_with ";")
              else
                (res, in_rule)
          else
            res.is_empty ? "" : (res.as_string new_line) + new_line


        ebnf_rules.replace "\"" "'"     # replace " by '

      .reduce ebnf_header (+)

    say ebnf

    # test grammar with antlr4
    tmp := !!"mktemp --directory"
    _ := !!"mkdir $tmp/fuzion_grammar"
    _ := io.file.write "$tmp/fuzion_grammar/Fuzion.g4" ebnf
    antlr := if ((os.process.start "antlr4").bind u32 p->p.wait).as_equatable = 0 then "antlr4" else "antlr"
    # NYI: UNDER DEVELOPMENT: add option -Werror
    _ := !!"$antlr -long-messages -o $tmp/fuzion_grammar $tmp/fuzion_grammar/Fuzion.g4"
    _ := !!"rm -Rf $tmp"
