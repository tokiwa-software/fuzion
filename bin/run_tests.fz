# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code run_tests script
#
# -----------------------------------------------------------------------


########### Extensions ###############

# stores the results of a process
#
process_result(out String, err String, exit_code u32) is

# specified environment variables as key,value array
#
envir_var_kv := [
  "PATH",
  "LANG",
  "JAVA_HOME",
  "POSTCONDITIONS",
  "PRECONDITIONS",
  "dev_flang_tools_serializeFUIR",
  "dev_flang_fuir_analysis_dfa_DFA_MAX_ITERATIONS",
  "CPATH",
  "LIBRARY_PATH",
  "FUZION_CLANG_INSTALLED_DIR",
  "OS",
  "INFLUXDB_TOKEN"
].map k->
  envir.vars[k].bind v->
    (k,v)
 .filter (.ok)
 .map (.val)
 .as_array

# envir vars as map
#
envir_vars :=
  (container.ordered_map
    (envir_var_kv
      .map (.0)
      .as_array)
    (envir_var_kv
      .map (.1)
      .as_array))

# max time a test may take
#
max_test_time := (time.duration.min 10)

# helper to get out, err, exit_code from started process
#
record_process(
      p os.process,
      # the command, for error messages
      cmd String
) process_result =>
  lm : mutate is
  (concur.thread_pool 2 ()->
      fout := concur.thread_pool.env.submit _ ()->
        lm ! ()->
          match p.with_out String lm (()->String.from (io.buffered lm).read_fully)
            e error => panic "failed reading stdout from $cmd, error is: $e"
            out String => out
      ferr := concur.thread_pool.env.submit _ ()->
        lm ! ()->
          match p.with_err String lm (()->String.from (io.buffered lm).read_fully)
            e error => panic "failed reading stderr from $cmd, error is: $e"
            err String => err

      match p.wait max_test_time
        e error => process_result "" "failed waiting for $cmd, error is: $e" 1
        ec u32 => process_result fout.get ferr.get ec)
    .get

# execute this Sequence of process+args
#
Sequence.prefix ! =>
  seq := map x->x.as_string
  os.process.start seq.first.val (seq.drop 1) envir_vars
            .bind (p -> record_process p Sequence.this.as_string)


# feed this string to a new process
#
String.infix | (seq Sequence String) =>

  lm : mutate is
  lm ! ()->
    match os.process.start seq.first.val (seq.drop 1) envir_vars
      e error => panic "failed executing $seq, error is $e"
      p os.process =>
        _ := p.with_in unit lm ()->
          # NYI: ambiguous result type:
          # _ := write_to lm
          _ := (io.buffered lm).writer.env.write String.this.utf8
          _ := (io.buffered lm).writer.env.flush
          _ := p.close_in
        record_process p seq.as_string


# execute this string by splitting at all whitespaces
#
String.prefix !! =>
  !split


append_line(mtx concur.sync.mutex, dest path, str String) =>

  mtx.synchronized ()->
    check (io.file.use dest io.file.mode.append ()->
            check ("$str\n".write_to io.file.file_mutate).ok).ok

is_windows =>
  (envir.vars["OS"].val "").lower_case.contains "windows"


########### run_tests ###############


find_tests(dir path) array path =>
  m : mutate is
  tests := m ! ()->
    io.dir.use _ dir ()->
      res := (m.array path).type.new 0 (path.of "")
      _ :=
        for x := io.dir.open.read
        while x.ok
          dir_x := dir.resolve x.val
          if io.file.exists (dir_x.resolve "Makefile")
            res.add dir_x
      res.as_array

  tests
    .val
    .as_array


say_section(str String) =>
  say ""
  say <| " $str ".pad_center "âŽ¯" 80
  say ""


#
# send something to our influx database
#
# e.g. post_to_influx "tokiwa" "benchmarks" "**token**" "tests,test=hello value=26.5"
#
post_to_influx(org, bucket, token, str String) =>
  web.post_r
    net.family.ipv4
    "https://influxdb.tokiwa.software:8086/api/v2/write?org={org}&bucket={bucket}&precision=s"
    str.utf8
    (container.map_of [("Authorization", "Token {token}"),
                       ("Content-Type", "text/plain")])



main =>

  mtx := concur.sync.mutex.new.val

  append_line(dest path, str String) =>
    append_line mtx dest str

  # NYI: UNDER DEVELOPMENT: react to Ctrl+c like in bash scripts (trap)

  if (envir.args.count != 3 && envir.args.count != 4)
    say "wrong argument count"
    say "usage:"
    say "run_tests.fz <build_dir> <target> [<n_threads>]"
    exit 1

  build_dir := path.of envir.args[1]
  target := envir.args[2]


  # source: https://stackoverflow.com/questions/45181115/portable-way-to-find-the-number-of-processors-cpus-in-a-shell-script
  # first, try third arg then try a few executables, if everything fails use default value
  thread_count :=
      envir.vars["FUZION_RUN_TESTS_PARALLELISM"]      .flat_map (    .trim.parse_i32) .first
        .or_else (     (!!"nproc --all"              ).flat_map (.out.trim.parse_i32) .first
          .or_else (   (!!"getconf _NPROCESSORS_ONLN").flat_map (.out.trim.parse_i32) .first
            .or_else ( (!!"sysctl -n hw.ncpu"        ).flat_map (.out.trim.parse_i32) .first
              .or_else 4)))

  tests := find_tests (build_dir.resolve "tests")

  check tests.count>500

  results  := build_dir.resolve "run_tests.results"
  failures := build_dir.resolve "run_tests.failures"

  _ := io.file.delete results
  _ := io.file.delete failures

  # for storing the elapsed time of each test
  test_durations := (lock_free.Map path time.duration).empty

  run_single_test(test path) =>
    if io.file.exists (test.resolve "skip") || io.file.exists (test.resolve "skip_$target") || (is_windows && (io.file.exists (test.resolve "skip_win")))
      yak "_"
      append_line results "$test: skipped"
    else

      opt_res, elapsed_time := time.stopwatch _ ()->
            !!"make $target --environment-overrides --directory=$test"

      test_durations.put test elapsed_time

      match opt_res
        e error =>
          yak "!"
          append_line results "$test in {elapsed_time}: $e error"
          append_line failures "$test: $e"
        res process_result =>
          if res.exit_code = 0 || target = "fuir" then
            yak "."
            append_line results "$test in {elapsed_time}: ok"
          else
            yak "#"
            append_line results "$test in {elapsed_time}: failed"
            append_line failures res.out
            append_line failures res.err


  say "{tests.count} tests, running $thread_count tests in parallel."



  elapsed_time_total := time.stopwatch ()->
    _ := concur.thread_pool thread_count ()->
      for t in tests do
        check concur.thread_pool.env.submit (run_single_test t)


  results_content := (io.slurp results)
    .val
    .lines
    .filter (x -> !x.is_blank)
    .as_array

  ok             := results_content.count (.ends_with "ok"     )
  skipped        := results_content.count (.ends_with "skipped")
  failed         := results_content.count (.ends_with "failed" )
  produced_error := results_content.count (.ends_with "error"  )

  say ""
  say ("$ok/{tests.count} tests passed" +
       ", $skipped skipped" +
       ", $failed failed" +
       (produced_error = 0 ? "" :", $produced_error produced error") +
       " in {elapsed_time_total.as_string.trim}.")

  max_recorded := test_durations
    .values
    .max
  h := time.histogram target nil max_recorded 0 0
  test_durations
    .values
    .for_each h.add
  say h

  if failed + produced_error > 0
    say_section "Failed tests"

    failed_tests := results_content.filter (.ends_with "failed")

    failed_tests.for_each say

    say_section "run_tests.failures START"
    say (io.slurp failures)
    say_section "run_tests.failures END"

    failed_test_names := failed_tests
                           .map (.split[0].substring 12) # remove "build/tests/"
                           .as_string " "

    say """
        To re-run all failed tests, use this command:
        for t in $failed_test_names; do
          make $target -C ./build/tests/\$t
        done
        """

    # NYI: UNDER DEVELOPMENT: if _target file exists: "make record_$target -C $x"
    say """
        To re-record all failed tests, use this command:
        for t in $failed_test_names; do
          make record -C ./build/tests/\$t
        done
        """

    check (set_exit_code 1).ok


  num_slowest := 10
  say_section "Slowest $num_slowest tests using $target backend"

  test_durations
    .items
    .sort_by (td1,td2 -> td2.1<=td1.1)
    .take num_slowest
    .for_each (td -> say "{td.1.as_string_pad} {td.0}")

  say_section "$target done"

  match
    {
    envir
      .vars
      .get "INFLUXDB_TOKEN"
    }
    nil => say "INFLUXDB_TOKEN not set, not sending to influxdb."
    token String =>
      data := test_durations.items
        .map td->"test_runtime,backend={target},test={td.0} value={td.1.millis}"
      if token.is_blank
        say "INFLUXDB_TOKEN is blank, not sending to influxdb."
      else
        say <| post_to_influx "tokiwa" "benchmarks" token.trim (String.join_lines data)
        say <| post_to_influx "tokiwa" "benchmarks" token.trim "run_tests,backend={target} total_time={elapsed_time_total.millis}"

  exit

_ := main
