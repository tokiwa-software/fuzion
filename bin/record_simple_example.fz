########### Extensions ###############

# specified environment variables as key,value array
#
envir_var_kv := [
  "PATH",
  "LANG",
  "JAVA_HOME",
  "POSTCONDITIONS",
  "PRECONDITIONS",
  "dev_flang_tools_serializeFUIR",
  "CPATH",
  "LIBRARY_PATH",
  "FUZION_CLANG_INSTALLED_DIR",
  "OS",
  "FUZION_HOME",
  "FUZION_JAVA",
  "FUZION_JAVA_STACK_SIZE",
  "FUZION_JAVA_OPTIONS",
  "FUZION_JVM_BACKEND_OPTIONS",
  "FUZION_C_BACKEND_OPTIONS",
  "FUZION_RANDOM_SEED",
  # set in simple.mk
  "LD_LIBRARY_PATH",
  "DYLD_FALLBACK_LIBRARY_PATH",
  "C_INCLUDE_PATH",
  "LANGUAGE"
].map k->
  (envir.vars.get k).bind v->
    (k,v)
 .filter o->o.ok
 .map o->o.val
 .as_array

# envir vars as map
#
envir_vars :=
  (container.ordered_map
    (envir_var_kv
      .map x->x.0
      .as_array)
    (envir_var_kv
      .map x->x.1
      .as_array))
  .add "FUZION_DISABLE_ANSI_ESCAPES" "true"



write_to_file(dest String, data String) =>
  _ := io.file.delete dest
  check (io.file.use dest io.file.mode.write ()->
    check (data.write_to io.file.file_mutate).ok).ok



####### record_simple_example ########


type_ := envir.args[1]
fz_run   := envir.args[2] # NYI: UNDER DEVELOPMENT: code should be same as check_simple_example.fz
file     := envir.args[3]

Custom_Process_Env : Process_Env is
  public redef envir_vars container.Map String String => universe.envir_vars

Process_Env.instate Custom_Process_Env ()->

  res :=
    if type_ = "jvm" || type_ = "any"
      "$fz_run -XmaxErrors=-1 -jvm {(envir.vars.get "FUZION_JVM_BACKEND_OPTIONS").get ""} $file".execute
    else if type_ = "c"
      c := "$fz_run -XmaxErrors=-1 -c {(envir.vars.get "FUZION_C_BACKEND_OPTIONS").get ""} -o=testbin $file".execute
      if (c.exit_code = 0)
        e := "./testbin".execute
        _ := io.file.delete "testbin"
        process_result c.out+e.out c.err+e.err e.exit_code
      else
        c
    else if type_ = "int"
      "$fz_run -XmaxErrors=-1 -interpreter $file".execute
    else if type_ = "effect"
      "$fz_run -XmaxErrors=-1 -effects $file".execute
    else
      panic "not supported"

  if type_ != "effect"
    sfx :=
      if type_ = "any"
        ""
      else
        "_$type_"

    write_to_file "$file.expected_out$sfx" res.out
    cur_dir := os.cwd.val
    write_to_file "$file.expected_err$sfx" (res.err.replace cur_dir "--CURDIR--")
  else
    write_to_file "$file.effect" ((res.out.lines.filter (l -> !l.is_empty)).sort.as_string "\n")+"\n"

  say "RECORDED $file"
