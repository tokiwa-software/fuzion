# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature float
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

# float -- floating point values
#
#
# float is the abstract parent of concrete floating point features such as
# f32 or f64.
#
float(redef F type : float F) : numeric F, floats F is


  # preconditions for basic operations: true if the operation's result is
  # representable for the given values.  For IEEE_754, all operations are
  # defined for all values.
  #
  redef prefix +! bool is true
  redef prefix -! bool is true
  redef infix +! (other F) bool is true
  redef infix -! (other F) bool is true
  redef infix *! (other F) bool is true
  redef infix /! (other F) bool is true
  redef infix %! (other F) bool is true
  redef infix **!(other F) bool is true


  # convert a float value to i64 dropping any fraction.
  # the value must be in the range of i64
  as_i64 i64 is abstract


  fract F is abstract


  # round floating point number
  # ties to away (0.5 => 1; -0.5 => -1; etc.)
  #
  # NYI this could be made faster, see here:
  # https://cs.opensource.google/go/go/+/refs/tags/go1.18.1:src/math/floor.go;l=79
  round F is
    if thiz < zero
      -(-thiz).round
    else if fract = zero
      thiz
    else
      (thiz + one/two).floor


  # floor: the greatest integer lower or equal to this
  floor F is
    if fract < zero
      thiz - fract - one
    else
      thiz - fract


  # ceiling: the smallest integer greater or equal to this
  ceil F is
    if fract ≤ zero
      thiz - fract
    else
      thiz - fract + one


  # number of bits used for mantissa,
  # including leading '1' that is not actually stored
  #
  type.significand_bits i32 is abstract

  # number of bits used for exponent
  #
  type.exponent_bits i32 is abstract


  # the amount of bits that are used to encode the mantissa
  type.mantissa_bits => significand_bits - 1


  # number of bytes required to store this value
  #
  type.bytes i32 is abstract


  # number of bits required to store this value
  #
  type.size => 8*bytes


  # eulers number 2.72..
  #
  type.ℇ float.this.type is abstract


  # pi 3.14...
  #
  type.π float.this.type is abstract


  # conversion
  #

  # convert an i64 value to a floating point value
  #
  # if the value cannot be represented exactly, the result is either
  # the nearest higher or nearest lower value
  #
  type.from_i64(val i64) float.this.type is abstract


  type.exponent_range => -min_exp..max_exp


  # non signaling not a number
  #
  type.quiet_NaN => F.zero / F.zero


  # not a number
  #
  type.NaN => quiet_NaN


  # is not a number?
  #
  type.is_NaN (val float.this.type) bool is abstract


  type.negative_infinity => -F.one / F.zero


  type.positive_infinity => F.one / F.zero


  # infinity
  #
  type.infinity => positive_infinity


  type.min_exp i32 is abstract
  type.max_exp i32 is abstract
  type.min_positive F is abstract
  type.max F is abstract
  type.epsilon F is abstract


  # square root
  #
  type.square_root (val float.this.type) float.this.type is abstract


  # square root alias
  #
  type.sqrt (val float.this.type) => square_root val


  # the `val`-th power of ℇ
  # i.e. ℇᵛᵃˡ
  #
  type.exp (val float.this.type) float.this.type is abstract


  # logarithm with base ℇ
  #
  type.log (val float.this.type) float.this.type is abstract


  # logarithm with base `base`
  #
  type.log (base, val F) F
  pre base > F.zero
  is
    (F.log val) / (F.log base)


  # trigonometric

  type.sin  (val float.this.type) float.this.type is abstract
  type.cos  (val float.this.type) float.this.type is abstract
  type.tan  (val float.this.type) float.this.type is abstract
  type.asin (val float.this.type) float.this.type is abstract
  type.acos (val float.this.type) float.this.type is abstract
  type.atan (val float.this.type) float.this.type is abstract
  type.atan2 (y, x float.this.type) float.this.type is abstract


  # hyperbolicus

  type.sinh (val float.this.type) float.this.type is abstract
  type.cosh (val float.this.type) float.this.type is abstract
  type.tanh (val float.this.type) float.this.type is abstract



# floats -- unit type defining features related to float but not requiring
# an instance
#
floats(F type : float F) : numerics F is

  # arcus hyperbolicus

  asinh(val F) F is
    # ln(x+sqrt(x^2+1))
    F.log (val + F.sqrt (val ** two + one))
  acosh(val F) F is
    # ln(x+sqrt(x^2-1))
    F.log (val + F.sqrt (val ** two - one))
  atanh(val F) F is
    # 1/2*ln((1+x)/(1-x))
    F.log ((one + val)/(one - val)) / two
