# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature stdin
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------


# stdin -- effect providing several features
# for consuming the given byteInputHandler
#
private stdin(
    ip byteInputHandler,
    # action to be taken: plain nomad, install or replace?
    redef r effectModes,
    _ unit
  ) : stdins, effect r is


  # for a stdin instance installed in the current environment,
  # install next instance of byteInputHandler,
  # 'stdin.env' will provide the new instance.
  #
  private next => stdin ip.next mode unit

  nextByte =>
    next.ip.get


  # stream of bytes read from stdin until and excluding EOF
  private byte_stream stream<u8> is

    val option<outcome<u8>> := nil

    read =>
      if val.isNil
        set val := stdin.nextByte

    reset =>
      set val := nil

    ref: stream<u8>
      redef hasNext bool is
        read
        match val
          nil => fuzion.std.panic "this should not be possible"
          v outcome<u8> =>
            match v
              error => false
              v u8 => true
      redef next u8 is
        read
        match val
          nil => fuzion.std.panic "this should not be possible"
          v outcome<u8> =>
            match v
              error => fuzion.std.panic "no next value in stream"
              v u8 =>
                reset
                v


  # read n codepoints from stdin
  read(n i32) string is
    tmp : string is
      redef utf8 Sequence<u8> is byte_stream
                                                            # asArray, since we don't want this to be lazy
    strings.fromCodepoints (tmp.asCodepoints.asStream.take n).asArray


  # read line from stdin
  read_line string is
    arr := byte_stream
      .takeWhile(b -> b != line_feed)
      .asArray                         # asArray, since we don't want this to be lazy
    strings.fromBytes arr


# short-hand for creating and installing stdin effect
stdin(h byteInputHandler, f () -> unit) =>
  stdin h (effectMode.inst f) unit
  unit

# short-hand for accessing stdin effect in current environment
stdin =>
  stdins.installDefault
  stdin.env

# unit feature providing static helpers
stdins is
  installDefault is
    if !(effects.exists<io.stdin>)
      _ := stdin (defaultInputHandler (error "not initialized")) effectMode.default unit

  # end-of-line marker
  #
  line_feed => u8 10


byteInputHandler ref is

  next byteInputHandler is abstract

  get outcome<u8> is abstract


# the default input handler reading bytes via fuzion.stdin.nextByte
defaultInputHandler(byte outcome<u8>) : byteInputHandler is

  next byteInputHandler is
    v := fuzion.stdin.nextByte
    if v < 0
      defaultInputHandler (error "an error occurred while reading stdin")
    else
      defaultInputHandler (outcome v.as_u8)

  get => byte
