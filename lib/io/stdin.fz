# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature stdin
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------


# stdin -- effect providing several features
# for consuming the given Byte_Input_Handler
#
public stdin(ip io.Byte_Input_Handler) : simple_effect is


  # read a single byte from stdin
  #
  byte =>
    (stdin ip.next).ip.get


  # an infinite list of either a byte, an end_of_file or an error
  # Caution!: this list is not immutable since it is constructed lazily by reading from stdin!
  # you may iterate only once.
  # Additionally there may be read more from stdin than what is consumed
  # via this list.
  # NYI: How can we lessen these imperfections?
  #
  bytes list (choice u8 io.end_of_file error) is
    list byte ()->bytes


  # read one codepoint from stdin
  # returns end_of_file if stdin is depleted or
  # error in case of an error while reading the codepoint
  #
  public codepoint choice codepoint io.end_of_file error is
    match byte
      b u8 =>
        match codepoint.type.num_utf8_bytes b
          n i32 =>
            rest := (2..n)
              # NYI use reduce_or_error once outcome is open generic
              .reduce (choice (Sequence u8) io.end_of_file error) [b] (r,t ->
                match r
                  seq Sequence u8 =>
                    match byte
                      b u8 => seq ++ [b]
                      io.end_of_file =>
                        abort (choice (Sequence u8) io.end_of_file error) io.end_of_file
                      e error =>
                        abort (choice (Sequence u8) io.end_of_file error) e
                  * => fuzion.std.panic "should not be possible"
                )
            match rest
              l Sequence u8 =>
                String
                  .type
                  .from_bytes l
                  .as_codepoints
                  .first
              io.end_of_file => io.end_of_file
              # error occurred while reading the rest of utf8 bytes
              e error => e

          # first byte is not the start of a utf8 codepoint
          encoding_err error => encoding_err

      # we are already at enf of file
      io.end_of_file => io.end_of_file

      # not even single byte could be read from stdin
      stdin_err error => stdin_err


  # a - possibly infinite - list of codepoints read from stdin
  # Caution!: this list is not immutable since it is constructed lazily by reading from stdin!
  # you may iterate only once.
  # Additionally there may be read more from stdin than what is consumed
  # via this list.
  # NYI: How can we lessen these imperfections?
  #
  public codepoints list (choice codepoint io.end_of_file error) is
    list codepoint ()->codepoints


  # outcome to be returned if stdin is already closed/depleted
  private eof_error outcome String is
    error "--- end of file ---"


  # read n codepoints from stdin or
  # less if an end_of_file is encountered
  # while reading
  #
  public read(n i32) outcome String
  pre n â‰¥ 0
  is
    (1..n)
      .reduce_or_error "" (r, t ->
        match codepoint

          c codepoint =>
            r + c

          io.end_of_file =>
            if r.is_empty then
              abort eof_error
            else
              abort (outcome r)

          e error =>
            abort (outcome String) e   // return only the error, discarding what we read so far
        )


  # read from stdin until end of line or end of file
  #
  public read_line outcome String is
    ascii := character_encodings.ascii
    codepoints
      .reduce_or_error "" (r, t ->
        match t

          c codepoint =>
            # end of line found, returning
            if c.val = ascii.lf.as_u32
              abort (outcome r)
            # ignore carriage return
            else if c.val = ascii.cr.as_u32
              r
            else
              r + c

          io.end_of_file =>
            if r.is_empty then
              abort eof_error
            else
              abort (outcome r)

          e error =>
            abort (outcome String) e
      )


  # install default instance of stdin
  #
  type.install_default =>
    (io.stdin (default_input_handler (error "not initialized"))).default


  # the default input handler reading bytes via fuzion.sys.stdin.next_byte
  #
  type.default_input_handler(r choice u8 io.end_of_file error) : io.Byte_Input_Handler is


    next io.Byte_Input_Handler is
      v := fuzion.sys.stdin.next_byte
      if v = -1
        default_input_handler io.end_of_file
      else if v < -1
        default_input_handler (error "an error occurred while reading stdin")
      else
        default_input_handler v.as_u8


    get => r



# short-hand for accessing stdin effect in current environment
#
public stdin =>
  stdin.type.install_default
  stdin.env



# Byte_Input_Handler -- abstract source of bytes
Byte_Input_Handler ref is

  # get the next instance of Byte_Input_Handler
  # which will contain the next byte or an error.
  #
  next io.Byte_Input_Handler is abstract


  # get the byte or error stored in this instance
  #
  # NYI using choice, until open generic for error in outcome is implemented
  #
  get choice u8 io.end_of_file error is abstract
