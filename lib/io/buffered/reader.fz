# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature io.buffered.reader
#
# -----------------------------------------------------------------------


# buffered.reader effect allows buffered reading
# by using the given Read_Provider
#
# note: anything in the buffer when effect is uninstalled will be discarded.
#
public reader(rp Read_Provider, buf_size i32) : try unit (e->raise e) unit unit
pre debug: buf_size > 0
is

  # a local mutate
  lm : mutate is
  lm_instance := lm

  # circular buffer backing this reader
  #
  buffer := lm_instance.instate_self (() -> (mutate.circular_buffer u8).new lm buf_size.as_i64 0)


  # has the end of file been reached?
  #
  eof := lm_instance.instate_self (() -> lm.env.new false)


  # read returns the current buffer or end of file.
  # in case the buffer is empty it fills the buffer
  # before returning it.
  #
  public read => read buf_size


  # read returns the current buffer or end of file.
  # in case the buffer is empty it fills the buffer
  # with up to n bytes before returning it.
  #
  public read(n i32) switch (array u8) io.end_of_file
    post
      debug: (result ? io.end_of_file => true | a array => !a.is_empty)
  =>
    # NYI: better type inference could turn this into
    # lm_instance.instate_self ()->
    lm_instance.instate_self (switch (array u8) io.end_of_file) ()->
      if eof.get
        io.end_of_file
      else
        if buffer.buffered = 0
          fill_buffer

        # fill_buffer could set this to true
        if eof.get
          io.end_of_file
        else
          # NYI: remove double buffering implementation outside of the reader,
          # just flush the buffer here.
          # m := min n.as_i64 buffer.buffered
          # buffer.flush m
          m := min n buffer.buffered.as_i32
          (buffer.as_array.slice 0 m).as_array



  # fill the currently empty buffer with up to buf_size bytes
  #
  fill_buffer unit
    pre
      debug: !eof.get
      debug: buffer.buffered = 0
    post
      debug: eof.get || buffer.buffered > 0
  =>
    match rp.read buffer.available.as_i32
      a array u8 =>
        match buffer.enqueue a
          unit =>
          e error => raise e
      io.end_of_file =>
        eof <- true
        replace
      e error => raise e


  # discard n items from buffer
  #
  public discard(n i32) unit
    pre
      debug: n >= 0
  =>
    lm_instance.instate_self ()->
      m := min n.as_i64 buffer.buffered
      _ := buffer.flush m


  # discard complete buffer
  #
  # NYI naming this feature discard leads to error: Duplicate feature declaration
  #
  public discard_all unit
  =>
    discard buf_size


  # short hand for getting the currently installed `buffered.reader`
  #
  type.reader =>
    reader.this.env


  # read n bytes using the currently installed byte reader effect
  # if the returned sequence is empty or count is less than n, end of file has been reached.
  #
  public type.read_bytes(n i32) Sequence u8 ! reader =>

    # NYI: BUG: we should be able to just use lm from reader.this.lm
    lm0 : mutate is
    lm0.instate_self ()->

      res := (mutate.array u8).new lm0

      _ :=
        for n_read := 0, n_read + r
        while n_read < n
          r := match reader.read   # NYI: we should limit the number of byted read by reader.read, we can exceed n!
              io.end_of_file => -1
              a (array u8) =>
                reader.discard a.length
                for b in a do
                  res.add b
                a.length
        until r < 0
      res.as_array


  # read string, up to n codepoints or until end of file
  # requires `buffered.reader` effect to be installed.
  #
  public type.read_string(n i32) String ! reader
  pre debug: n >= 0
  =>

    take_valid_codepoints(a Sequence u8, max i32) =>
      v := String.from_bytes a
        .codepoints_and_errors
        .take_while x->
          match x
            codepoint => true
            error => false
        .take max
        .map String x->
          match x
            c codepoint => c
            error => exit 1
        .as_array

      bytes_used := (v.map c->c.as_string.byte_length).fold i32.sum
      reader.discard bytes_used
      v

    for
      is_eof                 := reader.read ? io.end_of_file => true | a array => false
      next_bytes Sequence u8 := (reader.read ? io.end_of_file => []   | a array => a), rest ++ (reader.read ? io.end_of_file => [] | a array => a)
      next_codepoints        := take_valid_codepoints next_bytes n, take_valid_codepoints next_bytes n-codepoint_count
      # if we did not use any bytes and `next_bytes` contains not enough bytes for a codepoint potentially,
      # we trigger a `discard_all` and remember what we read so far via `rest`.
      # this is necesarry e.g. for stdin where we read one byte at a time.
      rest Sequence u8       := if n>0 && next_codepoints.is_empty && next_bytes.count < 4 then reader.discard_all; next_bytes else []
      codepoint_count        := next_codepoints.count, codepoint_count+next_codepoints.count
      res Sequence String    := next_codepoints, res ++ next_codepoints
    while !is_eof && codepoint_count < n
    else
      if is_eof && res.is_empty
        reader.raise (error "-- end of file --"); ""
      else
        String.join res


  # use the currently installed byte reader effect
  # to read until the specified delimiter byte occurs
  # if specified, strips carriage return bytes before
  # the delimiter before returning the read data
  #
  public type.read_delimiter (delim u8, strip_cr bool) switch String io.end_of_file ! reader =>

    # NYI: BUG: we should be able to just use lm from reader.this.lm
    lm0 : mutate is
    lm0.instate_self (switch String io.end_of_file) ()->

      if reader.read ? io.end_of_file => true | * => false
        io.end_of_file
      else
        res := (mutate.array u8).new lm0

        while
          match reader.read
            io.end_of_file =>
              false
            a array =>

              # trailing carriage returns are dropped
              add_to_res(a0 Sequence u8) unit =>
                if !a0.is_empty
                  a1 := if strip_cr && a0.last = encodings.ascii.cr
                            (a0.slice 0 a0.count-1)
                          else
                            a0
                  for b in a1 do
                    res.add b

              match a.index_of delim
                idx i32 =>
                  add_to_res (a.slice 0 idx)
                  reader.discard idx+1
                  false
                nil =>
                  add_to_res a
                  reader.discard_all
                  true

        ref : String
          redef utf8 Sequence u8 := res.as_array


  # use the currently installed byte reader effect
  # to read until a line feed occurs.
  # returns the line
  #
  public type.read_line switch String io.end_of_file ! reader =>
    read_delimiter encodings.ascii.lf true


  # Read input fully into an array of bytes until end_of_file is reached
  #
  public type.read_fully array u8 ! reader =>
    for
      r Sequence u8 := [], r++n
      n := read_bytes 8192
    while n.count > 0 else
      r.as_array


  # Read input fully and split it at the given delimiter. If specified, delete
  # any trailing carriage returns (ASCII 13) from the resulting strings.
  #
  public type.read_delimiter_full (delim String, strip_cr bool) array String ! reader =>
    String.from_bytes read_fully
      .split delim
      .map (s -> if strip_cr && s.ends_with "\r" then s.substring 0 s.byte_length-1 else s)
      .as_array


  # Read input fully and split it at linefeed (ASCII 10) characters. Delete
  # any trailing carriage returns (ASCII 13) from the resulting strings.
  #
  public type.read_lines array String ! reader =>
    read_delimiter_full "\n" true


  # Read input line by line calling `f` for each line until `f` returns false
  # or end_of_file is reached.
  #
  public type.read_line_while(f String -> bool) ! reader =>
    for s := "",  s + "\n" + match rl
                              s1 String => s1
                              io.end_of_file => panic "unreachable code path"
        rl := read_line
    while match rl
            str String => f str
            io.end_of_file => false
    else
      s
