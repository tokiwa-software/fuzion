# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature processes
#
# -----------------------------------------------------------------------


# effect for starting processes
#
public processes (ph os.Process_Handler, public running_processes container.Set os.process) : effect is


  # start a process with name, arguments and environment variables
  #
  module start(name String, args Sequence String, env_vars container.Map String String) =>
    (ph.start name args env_vars).bind os.process p->
      (os.processes ph (running_processes ∪ (container.set_of_ordered [p]))).replace
      p



  # cleanup effect
  #
  redef finally =>
    running_processes.for_each p->
      _ := wait p


  # wait for process to finish
  #
  # returns the exit code of the process or an error
  #
  module wait(p os.process) outcome u32
  pre running_processes.contains p
  =>
    (os.processes ph (running_processes ∖ (container.set_of_ordered [p]))).replace
    wait0 p


  # helper feature wait
  #
  wait0(p os.process) outcome u32 =>
    _ := fuzion.sys.pipe.close p.std_in = 0
    r := fuzion.sys.process.wait p.id
    if r<0
      error "Waiting for process with id {p.id} was unsuccessful."
    else
      # NYI close these:
      # check fuzion.sys.pipe.close p.std_out = 0
      # check fuzion.sys.pipe.close p.std_err = 0
      r.as_u32



  # install
install_default =>

  h : os.Process_Handler is

    # start process with option to pass environment variables
    #
    # helper feature for start and `infix |`
    #
    public redef start(n String, args Sequence String, env_vars container.Map String String) outcome os.process
    pre else
      # NYI: UNDER DEVELOPMENT: allow utf-8?
      # NYI: UNDER DEVELOPMENT: what about quotes(") ?
      debug: n.as_codepoints                          ∀ (y -> y.is_ascii)
      debug: args             ∀ (x -> x.as_codepoints ∀ (y -> y.is_ascii))
      debug: env_vars.keys    ∀ (x -> x.as_codepoints ∀ (y -> y.is_ascii))
      debug: env_vars.values  ∀ (x -> x.as_codepoints ∀ (y -> y.is_ascii))
    =>

      sys => fuzion.sys
      NULL := [u8 0].internal_array.data

      # posix_spawn needs last arg to be NULL
      arg_data := array fuzion.sys.Pointer args.count+2 i->
        if i=0 then sys.c_string n else if i<=args.count then sys.c_string args[i-1] else NULL

      env_var_strings := env_vars
        .items
        .map x->
          (k, v) := x
          "$k=$v"
        .as_array

      # posix_spawn needs last arg to be NULL
      env_data := array fuzion.sys.Pointer env_var_strings.count+1 (i -> if i<env_var_strings.count then sys.c_string env_var_strings[i] else NULL)

      # args as string for windows to avoid malloc in backend
      args_str := sys.c_string (String.type.join (([n]++args).map (x -> "\"" + x + "\"")) " ")

      # environment variables for windows to avoid malloc in backend
      # NULL terminates each environment variable
      # NULL is also used to terminate the environment variables data structure.
      env_str := sys.c_string ((String.type.join env_var_strings (codepoint 0)) + (codepoint 0))

      res_data := array i64 4 i->0
      if (sys.process.create arg_data.internal_array.data arg_data.count env_data.internal_array.data env_data.count res_data.internal_array.data args_str env_str) = -1
        error "*** error creating process ***"
      else
        os.process res_data[0] res_data[1] res_data[2] res_data[3]

  (os.processes h (container.ps_set os.process).empty).default



# short-hand to processes effect
#
public processes =>
  install_default
  processes.env


# Process_Handler
#
public Process_Handler ref is

  public start(name String, args Sequence String, env_vars container.Map String String) outcome os.process => abstract

