# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature fuzion.sys.net
#
# -----------------------------------------------------------------------

# groups networking related features
net is

  # create a new socket descriptor
  # on error a negative integer is returned.
  # on success zero or more is returned.
  socket i64 is intrinsic

  # bind server, zero on success
  # array data depends on the family.
  # - ipv4: first two bytes encode the port,
  #         then four bytes for the ip address
  # returns zero on success, anything else is an error.
  bind   (sd i64, family i32, arr_data Any, length i32) i32 is intrinsic

  # activates the server socket, setting a backlog
  # for maximum amount of connections which are kept
  # waiting for acceptance.
  # returns zero on success, anything else is an error.
  listen (sd i64, backlog i32) i32 is intrinsic

  # accept a new connection for given socket.
  # blocks until there is a connection to accept.
  # returns a new / different descriptor which
  # corresponds to the accepted connection only.
  # on error a negative integer is returned.
  # on success zero or more is returned.
  accept (sd i64) i64 is intrinsic

  # connect the socket.
  # details depend on the used family:
  # - ipv4: first two bytes encode the port,
  #         then four bytes for the ip address
  # returns zero on success, anything else is an error.
  connect(sd i64, family i32, arr_data Any, length i32) i32 is intrinsic


  # NYI these numbers are system dependent

  tcp is
  udp is
  local is
  ipv4 is
  ipv6 is
  stream is
  raw is


  protocols : choice ipv4 tcp udp ipv6 is
    num i32 is
      match protocols.this
        ipv4 => 0
        tcp => 6
        udp => 17
        ipv6 => 41

  family : choice local ipv4 ipv6 is
    num i32 is
      match family.this
        local => 1  # pipes etc.
        ipv4  => 2
        ipv6  => 10

  socket_type : choice stream raw is
    num i32 is
      match socket_type.this
        stream stream => 2
        raw raw => 3


  # read buffer in bytes
  buffer_size u64 := 1000


  # NYI blocking / none blocking
  private read_from(descriptor i64) list (outcome u8) : fuzion.sys.fileio is
    match read descriptor buffer_size
      arr array u8 =>
        match arr.as_list
          nil => nil
          c Cons u8 (list u8) =>
            list_of (outcome u8) c.head c.tail.map((outcome u8), (x -> x))
            # list_of (outcome u8) c.head (c.tail.map((outcome u8), (x -> x)).concat2 (()->read_from descriptor))
      err error =>
        list_of (outcome u8) err nil


  # NYI collect occured errors
  private read_until_error(descriptor i64) list u8 is
    (read_from descriptor).take_while(x ->
      match x
        u8 => true
        error => false
    ).map(x ->
      match x
        b u8 => b
        error => panic "should not be possible")



  // NYI can we yield control so that we can abort on error?
  // NYI should we ensure, read is only called once?

  server(f family, port u16, read_write (() -> list u8, (Sequence u8) -> outcome unit) -> bool)
    outcome unit : fuzion.sys.fileio
  is

    backlog := 10

    # open socket
    sd := socket

    if sd = -1
      error "a new socket could not be created"
    else
      port_addr array u8:= (port.as_bytes ++ [u8 0, u8 0, u8 0, u8 0]).as_array
      # bind to port
      if (bind sd f.num port_addr.internalArray.data port_addr.length) != 0
        close sd
        error "binding server socket to port $port failed."
      else
        # listen
        if (listen sd backlog) = -1
          close sd
          error "listening on socket failed."
        else
          for cd := accept sd, accept sd
          while cd != -1 && (read_write
              # reading
              (() -> read_until_error cd)
              # writing
              ((data) -> write cd data.as_array)
            )
          else
            # NYI better type inference needed
            res outcome unit := (if cd = -1
              close sd
              error "there was an error accepting a new connection."
            else
              match close cd
                err error =>
                  close sd
                  err
                unit      =>
                  close sd
                )
            res



  client(addr Sequence u8, port u16, read_write (() -> list u8, (Sequence u8) -> outcome unit) -> unit)
    outcome unit : fuzion.sys.fileio
  pre  (addr.count = 32/8   # ipv4
     || addr.count = 128/8) # ipv6
  is

    family_of(addr Sequence u8) family is
      if addr.count = 32/8 then ipv4 else ipv6

    # open socket
    sd := socket

    if sd = -1
      error "a new socket could not be created"
    else
      port_addr array u8 := (port.as_bytes ++ addr).as_array

      # connect to addr, port
      if (connect sd (family_of addr).num port_addr.internalArray.data port_addr.length) != 0
        close sd
        error "connecting client socket to addr {addr} port $port failed."
      else
        (read_write
          # reading
          (() -> read_until_error sd)
          # writing
          ((data) -> write sd data.as_array))

        close sd

