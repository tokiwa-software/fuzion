# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature ctrie
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------

# A Fuzion implementation of CTrie invented by Aleksandar Prokopec
# CTrie is a non-blocking concurrent hash trie
#
# reference paper: Concurrent Tries with Efficient Non-Blocking Snapshots
# https://aleksandar-prokopec.com/resources/docs/ctries-snapshot.pdf
#
# reference implementation in Scala: https://github.com/axel22/Ctries/
# on wikipedia: https://en.wikipedia.org/wiki/Ctrie
#
# Complexity (according to the paper):
# add, lookup, remove                     : O(log n)
# snapshot, amortized size retrieval, clear  : O(1)
#
# While CTrie is lock-free and guaranteed to make progress as a whole
# it is not wait-free and thus no such guarantee is given per thread.
#
# NYI addif
# NYI equality comparison could be ref equality
# NYI generation might overflow, which might lead to weird effects.
#
# glossary:
# CTK => ctrie key
# CTV => ctrie value
# k   => key
# v   => value
# gen => generation
# lev => level
# bmp => bitmap
# idx => index
# W   => 2^W-way branching factor
#


# a tomb node
# "a T-node is the last value assigned to an I-node"
private tomb_node(CTK type : property.hashable, CTV type, sn singleton_node CTK CTV) : property.equatable is
  module redef as_string => "tomb_node($sn)"

  as_list => sn.as_list

  fixed type.equality(a, b container.tomb_node CTK CTV) bool is
    a.sn = b.sn


# a singleton node
# the node type containing actual data
private singleton_node(CTK type : property.hashable, CTV type, k CTK, v CTV) : property.equatable  is
  module redef as_string => "singleton_node($k, $v)"

  as_list => [(k,v)].as_list


  fixed type.equality(a, b container.singleton_node CTK CTV) bool is
    a.k = b.k


# an indirection or a singleton node
# these are put into a container node
private branch(CTK type : property.hashable, CTV type) : choice (Indirection_Node CTK CTV) (singleton_node CTK CTV), property.equatable is
  module redef as_string =>
    match branch.this
      indirection_node Indirection_Node => "$indirection_node"
      singleton_node singleton_node => "$singleton_node"

  as_list =>
    match branch.this
      indirection_node Indirection_Node => indirection_node.as_list
      singleton_node singleton_node => singleton_node.as_list

  fixed type.equality(a, b container.branch CTK CTV) bool is
    match a
      ai container.Indirection_Node =>
        match b
          bi container.Indirection_Node => ai = bi
          bs container.singleton_node => false
      as container.singleton_node =>
        match b
          bi container.Indirection_Node => false
          bs container.singleton_node => as = bs


# a container node
# consists of a bitmap of filled spaces and an array of child nodes
private container_node(CTK type : property.hashable, CTV type, bmp u32, array array (branch CTK CTV)) : property.equatable is

  # update a child node and return a new container_node
  update(pos u32, node branch CTK CTV) =>
    container_node bmp (array.put pos.as_i32 node)

  # add a child node and return a new container_node
  add(sn singleton_node CTK CTV, pos, flag u32) =>
    container_node (bmp | flag) (array.insert pos.as_i32 sn).as_array

  # remove a child node and return a new container_node
  remove(pos, flag u32) =>
    # NYI delete/remove should be in stdlib
    tmp := array.take pos.as_i32 ++ array.drop (pos + 1).as_i32
    container_node (bmp ^ flag) tmp.as_array

  module redef as_string => "container_node({array.as_string ", "})"

  as_list => array.flat_map_sequence (tuple CTK CTV) (b -> b.as_list)
                 .as_list

  fixed type.equality(a, b container.container_node CTK CTV) bool is
    a.bmp = b.bmp
      && (container.searchable_sequence a.array) = (container.searchable_sequence b.array)


# NYI ref, work around for issue #1604
Nil ref is


# a prev_node is used in the generation aware compare and swap
#
# Main_Node.prev is initially nil
# when a Main_Node is replaced it is put into
# the successors `prev`-field.
#
private prev_node(CTK type : property.hashable, CTV type) : choice (Failed_Node CTK CTV) (Main_Node CTK CTV) Nil, property.equatable is

  module redef as_string =>
    match prev_node.this
      f container.Failed_Node => f.as_string
      m container.Main_Node => m.as_string
      Nil => nil.as_string

  fixed type.equality(a, b container.prev_node CTK CTV) bool is
    match a
      fa container.Failed_Node =>
        match b
          fb container.Failed_Node => fa = fb
          m container.Main_Node => false
          container.Nil => false
      ma container.Main_Node =>
        match b
          f container.Failed_Node => false
          mb container.Main_Node => ma = mb
          container.Nil => false
      container.Nil =>
        match b
          f container.Failed_Node => false
          m container.Main_Node => false
          container.Nil => true


# a container, tomb or linked list node, with a previous field
# to support the generational compare and swap
#
private Main_Node(CTK type : property.hashable, CTV type, data choice (container_node CTK CTV) (tomb_node CTK CTV) (list_node CTK CTV)) ref /* needs ref, cyclic layout container->indirection->main*/ : property.equatable is

  # compare and update `prev`
  cas_prev(o,n prev_node CTK CTV) =>
    prev.compare_and_set o n

  # a previous node that gets set during a generational aware compare and set
  prev := concur.atomic (prev_node CTK CTV) Nil

  redef as_string =>
    s := match data
      container_node container_node => "$container_node"
      tomb_node tomb_node => "$tomb_node"
      list_node list_node => "$list_node"
    "Main_Node[prev={prev.read}]($s)"

  # equality
  #
  fixed type.equality(a, b container.Main_Node CTK CTV) bool is
    a.prev.read = b.prev.read &&
      (match a.data
         ca container.container_node =>
          match b.data
            cb container.container_node => ca = cb
            tb container.tomb_node => false
            lb container.list_node => false
         ta container.tomb_node =>
          match b.data
            cb container.container_node => false
            tb container.tomb_node => ta = tb
            lb container.list_node => false
         la container.list_node =>
          match b.data
            cb container.container_node => false
            tb container.tomb_node => false
            lb container.list_node => la = lb
      )

  as_list
  pre match prev.read
    Nil => true
    * => false
   =>
    match data
      container_node container_node => container_node.as_list
      tomb_node tomb_node => tomb_node.as_list
      list_node list_node => list_node.map_sequence (sn -> (sn.k, sn.v))


# a failed node where the previous indirection node contains a main node
# NYI ref, work around for issue #1604
private Failed_Node(CTK type : property.hashable, CTV type, prev Main_Node CTK CTV) ref : property.equatable is

  redef as_string =>
    "Failed_Node($prev)"

  fixed type.equality(a, b container.Failed_Node CTK CTV) bool is
    a.prev = b.prev


# shorthand for creating a new indirection node from Main_Node and gen
private indirection_node(CTK type : property.hashable, CTV type, data Main_Node CTK CTV, gen i32) =>
  Indirection_Node (concur.atomic data) gen


# an indirection node
private Indirection_Node(CTK type : property.hashable, CTV type, data concur.atomic (Main_Node CTK CTV), gen i32) ref /* NYI removing this ref leads to segfaults */ : property.equatable is

  # NYI ref equality
  #
  fixed type.equality(a, b container.Indirection_Node CTK CTV) bool is
    a.gen = b.gen && a.data.read = b.data.read

  # compare and update
  private cas(old_n, new_n Main_Node CTK CTV) bool is
    data.compare_and_set old_n new_n

  module redef as_string => "Indirection_Node[gen=$gen]({data.read})"

  as_list list (tuple CTK CTV)
  pre match data.read.prev.read
    Nil => true
    * => false
  is data.read.as_list


# a linked list node
# NYI instead of Sequence we should use something like the original implementation ListMap(Scala).
private list_node(CTK type : property.hashable, CTV type, from Sequence (singleton_node CTK CTV)) : Sequence (singleton_node CTK CTV), property.equatable
pre from ∀ (sn -> (from.filter (snn -> sn.k.hash = snn.k.hash)).count = 1)
is
  redef as_list => from.as_list

  # is this sequence known to be finite?  For infinite sequences, features like
  # count diverge.
  #
  redef finite => true

  redef as_string => "list_node({from.as_string ", "})"

  # find k in linked nodes
  private find(k CTK) choice restart not_found CTV is
    match drop_while(sn -> sn.k != k).head
          nil => not_found
          sn singleton_node => sn.v

  fixed type.equality(a, b container.list_node CTK CTV) bool is
    (container.searchable_sequence a.from) = (container.searchable_sequence b.from)


# unit type to indicate an operation did not succeed yet
# and thus needs a restart
private restart is

# unit type to indicate success
private ctrie_ok is

# unit type to indicate when value to lookup/remove is not found
private not_found is
  public redef as_string => "not found"


# descriptor for double-compare-single-swap operation
# NYI ref, work around for issue #1604
private Rdcss_Descriptor(CTK type : property.hashable, CTV type, ov Indirection_Node CTK CTV, exp Main_Node CTK CTV, nv Indirection_Node CTK CTV) ref is

  # this field does not have to be atomic
  # but it probably does not hurt either.
  committed := concur.atomic false

  redef as_string =>
    "Rdcss_Descriptor($ov, $exp, $nv)"


# the root node of the ctrie, normally an indirection node.
# in case the root node is currently replaced it is a Rdcss_Descriptor temporarily.
private root_node(CTK type : property.hashable, CTV type) : choice (Indirection_Node CTK CTV) (Rdcss_Descriptor CTK CTV) is

  redef as_string =>
    s := match root_node.this
      i container.Indirection_Node => i.as_string
      r container.Rdcss_Descriptor => r.as_string
    "root_node($s)"


# the ctrie
private:public ctrie(CTK type : property.hashable, CTV type, private root concur.atomic (root_node CTK CTV), private read_only bool) : Map CTK CTV
is

  # the data structure as human readable string
  # for debugging purposes
  as_string_internal =>
    "Ctrie[ro=$read_only]({root.read})"

  # compare and swap root of the ctrie
  private cas_root(ov, nv root_node CTK CTV) =>
    root.compare_and_set ov nv


  # copy an indirection node to a new generation
  # this is used when
  # 1) taking a snapshot and the root node needs to be copied to a new generation
  # 2) copying a container node to a new generation
  #
  copy_to_gen(i Indirection_Node CTK CTV, new_gen i32) Indirection_Node CTK CTV is
    indirection_node (gcas_read i) new_gen


  # copy this container_node to new generation
  renew(cn container_node CTK CTV, new_gen i32) container_node CTK CTV is
    copy := cn
      .array
      .map (branch CTK CTV) x->
        match x
          i Indirection_Node => copy_to_gen i new_gen
          sn singleton_node => sn
      .as_array
    container_node cn.bmp copy


  # complete the double compare and swap
  # of the root node
  private rdcss_complete(abortable bool) Indirection_Node CTK CTV
  is
    match root.read
      # there is nothing to do
      n Indirection_Node => n

      desc Rdcss_Descriptor =>
        if abortable
          if cas_root desc desc.ov
            desc.ov
          else
            rdcss_complete abortable
        else
          old_main := gcas_read desc.ov
          if old_main = desc.exp
            if cas_root desc desc.nv
              desc.committed.write true
              desc.nv
            else
              rdcss_complete abortable
          else
            if cas_root desc desc.ov
              desc.ov
            else
              rdcss_complete abortable


  # read root
  # if root is currently a descriptor we are in the middle
  # of a double compare and swap.
  # Then (try) committing the descriptor first
  private read_root(abortable bool) Indirection_Node CTK CTV
  is
    match root.read
      n Indirection_Node => n
      d Rdcss_Descriptor => rdcss_complete abortable


  # read root none abortably
  private read_root => read_root false


  # do a double compare and swap of root node
  # 1. try compare and swap root
  # 2. if successful complete committing the descriptor
  private rdcss_root(desc Rdcss_Descriptor CTK CTV) =>
    try_commit =>
      rdcss_complete false
      desc.committed.read

    cas_root desc.ov desc &&
      try_commit

  # completes the generation sensitive compare and set
  private gcas_commit(i Indirection_Node CTK CTV, m Main_Node CTK CTV) Main_Node CTK CTV is
    prev := m.prev.read
    # abortably read root and get the current gen
    root_gen := (read_root true).gen
    match prev
      Nil => m
      fn Failed_Node =>
        if i.cas m fn.prev
          fn.prev
        else
          gcas_commit i i.data.read
      n Main_Node =>
        if root_gen = i.gen && !read_only
          if m.cas_prev n Nil
            m
          else
            gcas_commit i m
        else
          m.cas_prev n (Failed_Node n)
          gcas_commit i i.data.read

  # read `data`, if prev is set commit first
  private gcas_read(i Indirection_Node CTK CTV) Main_Node CTK CTV is
    m := i.data.read
    match m.prev.read
      Nil => m
      * => gcas_commit i m

  # generation aware compare and set
  # semantics on the indirection node i
  # o is compared and swapped with n
  # but this compare and swap only succeeds if the root
  # generation does not increase while this compare and
  # swap is taking place.
  private gcas(i Indirection_Node CTK CTV, o Main_Node CTK CTV, n Main_Node CTK CTV) choice restart ctrie_ok
  pre (match n.prev.read
        Nil => true
        * => false),
      n.cas_prev n.prev.read o
  is
    if i.cas o n
      gcas_commit i n
      match n.prev.read
        Nil => ctrie_ok
        * => restart
    else
      restart


  # the width of the branching factor, 2^5 = 32
  private width := u32 5


  # convert u64 hash to u32 hash
  private hash(h u64) u32 is
    h.low32bits


  # returns flag and the position in the container_node for given params
  private flagpos(hash u32, lev u32, bmp u32) tuple u32 u32 is
    idx := (hash >> lev) & 0x1F
    flag := u32 1 << idx
    mask := flag -° 1
    pos := (bmp & mask).ones_count.as_u32
    (flag, pos)


  # compress a container node
  private compress(cn container_node CTK CTV, lev u32) =>
    narr := cn.array.map (branch CTK CTV) n->
      match n
        m Indirection_Node =>
          match (gcas_read m).data
            // resurrect
            tn tomb_node => tn.sn
            * => m
        sn singleton_node => sn
    contract (container_node cn.bmp narr) lev


  # contract a container node
  private contract(cn container_node CTK CTV, lev u32) Main_Node CTK CTV is
    if (lev > (u32 0)) & (cn.array.length = 1)
      match cn.array[0]
        sn singleton_node => Main_Node (tomb_node sn)
        i Indirection_Node => Main_Node cn
    else
      Main_Node cn


  # clean an indirection node:
  # compress contained container node
  private clean(nd option (Indirection_Node CTK CTV), lev u32) =>
    nd.bind unit (inode ->
      m := gcas_read inode
      match m.data
        c container_node => gcas inode m (compress c lev)
        * =>
      unit
    )


  # turns this: container_node -> Indirection_Node -> tomb_node -> singleton_node
  # into  this: container_node -> singleton_node
  private clean_parent(parent option (Indirection_Node CTK CTV), i Indirection_Node CTK CTV, hash, lev u32) =>
    parent >>= p->
      m := gcas_read p
      match m.data
        cn container_node =>
          (flag, pos) := flagpos hash lev cn.bmp
          if (cn.bmp & flag) != u32 0
            sub := cn.array[pos.as_i32]
            match sub
              inode Indirection_Node =>
                if inode = i
                  match (gcas_read i).data
                    tn tomb_node =>
                      ncn := cn.update pos tn.sn
                      match gcas p m (contract ncn lev)
                        restart => clean_parent p i hash lev
                        ctrie_ok =>
                    * =>
              * =>
        * =>
      nil


  # takes two single nodes and returns either
  # Main_Node -> container_node -> singleton_nodes
  # or
  # Main_Node -> list_node -> singleton_nodes
  # or recurse
  # Main_Node -> container_node -> Indirection_Node -> dual x y
  private dual(x, y singleton_node CTK CTV, lev u32, gen i32) Main_Node CTK CTV is
    # NYI why 35??
    if lev < (u32 35)
      xidx := ((hash x.k.hash) >> lev) & 0x1f
      yidx := ((hash y.k.hash) >> lev) & 0x1f
      bmp := (u32 1 << xidx) | (u32 1 << yidx)
      if xidx = yidx
        sub_node := indirection_node (dual x y (lev + width) gen) gen
        Main_Node (container_node CTK CTV bmp [sub_node])
      else
        if (xidx < yidx)
          Main_Node (container_node CTK CTV bmp [x, y])
        else
          Main_Node (container_node CTK CTV bmp [y, x])
    else
      Main_Node (list_node [(singleton_node x.k x.v), (singleton_node y.k y.v)])


  # lookup key k
  public lookup(k CTK) option CTV is
    r := read_root
    res := lookup r k 0 nil r.gen
    match res
      r restart =>
        lookup k
      not_found =>
        nil
      v CTV =>
        v


  # try lookup key in ctrie
  # may fail and result in a restart
  private lookup(i Indirection_Node CTK CTV, k CTK, lev u32, parent option (Indirection_Node CTK CTV), gen i32) choice restart not_found CTV is
    m := gcas_read i
    match m.data
      cn container_node =>
        (flag, pos) := flagpos (hash k.hash) lev cn.bmp
        if (cn.bmp & flag) = (u32 0)
          not_found
        else
          match cn.array[pos.as_i32]
            sin Indirection_Node =>
              if read_only || gen = sin.gen
                lookup sin k (lev + width) i gen
              else
                match gcas i m (Main_Node (renew cn gen))
                  ctrie_ok => lookup i k lev parent gen
                  restart => restart
            sn singleton_node =>
              if sn.k = k
                sn.v
              else
                not_found
      tn tomb_node =>
        clean parent (lev - width)
        restart
      ln list_node => ln.find k


  # add key value
  # if key is already present value is updated
  public add(k CTK, v CTV) unit is
    r := read_root
    match add r k v 0 nil r.gen
      r restart =>
        add k v
      ctrie_ok =>
        unit


  # try adding an element to the ctrie
  # may fail and result in a restart
  private add(i Indirection_Node CTK CTV, k CTK, v CTV, lev u32, parent option (Indirection_Node CTK CTV), gen i32) choice restart ctrie_ok is
    m := gcas_read i
    match m.data
      cn container_node =>
        (flag, pos) := flagpos (hash k.hash) lev cn.bmp
        if (cn.bmp & flag) = (u32 0)
          ncn := (if i.gen = gen then cn else renew cn gen).add (singleton_node k v) pos flag
          gcas i m (Main_Node ncn)
        else
          match cn.array[pos.as_i32]
            ci Indirection_Node =>
              if ci.gen = gen
                add ci k v (lev+width) i gen
              else
                match gcas i m (Main_Node (renew cn gen))
                  ctrie_ok => add i k v lev parent gen
                  restart => restart
            sn singleton_node =>
              if sn.k != k
                nin := indirection_node (dual sn (singleton_node k v) (lev + width) i.gen) i.gen
                ncn := (if i.gen = gen then cn else renew cn gen).update pos nin
                gcas i m (Main_Node ncn)
              else
                gcas i m (Main_Node (cn.update pos (singleton_node k v)))
      tn tomb_node =>
        clean parent (lev - width)
        restart
      ln list_node =>
        gcas i m (Main_Node (list_node ([singleton_node k v] ++ (ln.filter (sn -> sn.k != k)))))


  # remove key from ctrie
  public remove(k CTK) choice not_found CTV is
    r := read_root
    match remove r k 0 nil r.gen
      r restart => remove k
      n not_found => n
      v CTV => v


  # try remove an element from the ctrie
  # may fail and result in a restart
  private remove(i Indirection_Node CTK CTV, k CTK, lev u32, parent option (Indirection_Node CTK CTV), gen i32) choice restart not_found CTV is
    m := gcas_read i
    match m.data
      cn container_node =>
        (flag, pos) := flagpos (hash k.hash) lev cn.bmp
        if (cn.bmp & flag) = (u32 0)
          not_found
        else
          res choice restart not_found CTV := match cn.array[pos.as_i32]
            sin Indirection_Node =>
              if sin.gen = gen
                remove sin k (lev + width) i gen
              else
                match gcas i m (Main_Node (renew cn gen))
                  ctrie_ok => remove i k lev parent gen
                  restart => restart
            sn singleton_node =>
              if sn.k != k
                not_found
              else
                match gcas i m (contract (cn.remove pos flag) lev)
                  ctrie_ok => sn.v
                  restart => restart
          match res
            v CTV =>
              match (gcas_read i).data
                t tomb_node => clean_parent parent i hash(k.hash) (lev - width)
                * =>
            * =>
          res
      tn tomb_node =>
        clean parent (lev - width)
        restart
      ln list_node =>
        fln := list_node ln.filter(sn -> sn.k != k)
        nln Main_Node CTK CTV := if fln.count = 1 then Main_Node (tomb_node fln.first) else Main_Node fln
        match gcas i m nln
          ctrie_ok => ln.find k
          restart => restart


  # the size of the ctrie
  public redef size i32 is
    items.count


  # lookup an element in this ctrie via bracket syntax
  public redef index [] (k CTK) option CTV is
    lookup k


  # take a snapshot of the ctrie
  public snapshot(read_only bool) ctrie CTK CTV is
    root := read_root
    expmain := gcas_read root
    descriptor := Rdcss_Descriptor root expmain (copy_to_gen root (root.gen +° 1))
    if rdcss_root descriptor
      # new ctrie by increasing gen of root by one
      ctrie CTK CTV (concur.atomic (root_node CTK CTV) (copy_to_gen root (root.gen +° 1))) read_only
    else
      snapshot read_only


  # a snapshot of the ctrie as sequence auf key-value tuples
  public redef items Sequence (tuple CTK CTV) is
    snapshot true
      .read_root
      .as_list


  # initialize a new ctrie
  public type.empty =>

    initial_gen := 0

    initial_root_node container.root_node CTK CTV :=
      container.indirection_node (container.Main_Node (container.container_node CTK CTV 0 [])) initial_gen

    container.ctrie CTK CTV (concur.atomic initial_root_node) false


  # ctrie.type.from_entries -- routine to initialize a ctrie from a sequence of key value tuples
  #
  # This feature creates an instance of a ctrie.
  #
  # example: ctrie.type.from_entries [(key1, value1), (key2, value2)]
  #
  public type.from_entries(kvs Sequence (tuple CTK CTV)) container.ctrie CTK CTV is

    m := (container.ctrie CTK CTV).type.empty
    kvs.for_each (kv ->
      (k,v) := kv
      m.add k v)

    m
