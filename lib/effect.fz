# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature effect
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

# effect -- abstract parent feature for effects
#
# effect provides a means to perform effectful operations.  Instances
# of effect are installed in the current environment while their code is
# executed.  The code may access the effect via <type>.env.
#
public effect is


  # --------------------  effect intrinsics  --------------------


  # set default effect in the current context to this if none is
  # installed
  #
  type.default0(e effect.this) unit => intrinsic


  # instate e for effect type effect.this in the current environment.
  #


  # execute code provided in f.call while this effect is instated in the
  # current environment and remove the instated effect after f.call returned.
  #
  # In case of an abort, run `def.call` on the latest value instated or replaced
  # for `effect.this` after removing that instated effect value.
  #
  type.instate0(C type : Function unit,
                D type : Function unit effect.this,
                e effect.this,
                c C,
                d D) unit => intrinsic


  # replace existing effect of type `E` in the new effect value `e`
  #
  type.replace0(e effect.this) unit => intrinsic


  # Intrinsic version of abort.
  #
  type.abort0(e effect.this) void => intrinsic


  # has an effect of this type been instated?
  #
  type.is_instated0 bool => intrinsic


  # --------------------  default effects  --------------------


  # set default instance for effect type `effect.this` to `e`
  #
  # NYI: UNDER DEVELOPMENT: This is a manual work-around to automatically install
  # default effects. It should be replaced by a effect configuration file that
  # is defined locally to a fuzion project or globally to the fuzion installation
  # the defines the default effects to be used. The DFA should then automatically
  # determine the required effects and create code to  instate them at the beginning
  # of an application.
  #
  public type.default(e effect.this) => default0 e


  # convenience version of `type.default` for effect values whose type is
  # exactly the effect type (i.e., the value type does not inherit
  # from the effect type).
  #
  # set default instance for effect type `effect.this` to value `effect.this`.
  #
  # NYI: UNDER DEVELOPMENT: See type.default
  #
  public default unit
  =>
    effect.this.type.default effect.this


  # --------------------  effect instation  --------------------


  # execute 'code' in a context where the effect instance `e` has been
  # installed for effect type `effect.this`.
  #
  # In case `f` returns normally, this will return `f`'s result.
  #
  # In case `f` aborts this effect, return `def()`.
  #
  public type.instate(# result type
                      R type,

                      # the effect value to instate
                      e effect.this,

                      # the code to execute with `e` instated.
                      code () -> R,

                      # the lazy default result to use if effect aborts
                      def effect.this -> R
                      ) R
  =>
    c := Effect_Call code
    d := Effect_Call2 def
    instate0 (Effect_Call R) (Effect_Call2 R effect.this) e c d
    c.r.or_else d.r.get


/* NYI: Causes fz to crash! **
  type.Effect_Call(f () -> R) : Function R is
    redef call => f()
*/


  # execute 'code' in a context where the effect instance `e` has been
  # installed for effect type `effect.this`.
  #
  # In case `f` returns normally, this will return `f`'s result.
  #
  # In case `f` aborts this effect, this will panic.
  #
  public type.instate(# result type
                      R type,

                      # the effect value to instate
                      e effect.this,

                      # the code to execute with `e` instated.
                      code () -> R
                      ) R
  =>
    instate R e code (_ -> panic "unexpected abort in {effect.this.type}")


  # convenience version of `instate` for effect values whose type is
  # exactly the effect type (i.e., the value type does not inherit
  # from the effect type).
  #
  # Execute 'code' in a context where this effect instance has been
  # installed for effect type `effect.this`.
  #
  # In case `f` returns normally, this will return `f`'s result.
  #
  # In case `f` aborts this effect, this will panic.
  #
  public instate_self(# result type
                      R type,

                      # the code to execute with `e` instated.
                      code () -> R
                      ) R
  =>
    effect.this.instate R effect.this code


  # has an effect of this type been instated?
  #
  public type.is_instated bool => is_instated0


  # has an effect of the given type been installed?
  public type.get_if_installed option effect.this
  =>
    if effect.this.is_instated
      unsafe_get
    else
      nil


  # internal helper to perform `E.env` without producing an error
  # in case static analysis fails to verify that `effect.this` is
  # actually installed.
  #
  type.unsafe_get =>
    effect.this.env


  # --------------------  replacing effect instances  --------------------


  # replace existing effect for type `effect.this` by the new effect value `e`.
  #
  # For effects that model the outside world (e.g., i/o, time, sensors and actuators, etc.),
  # the effect might be a unit type, so the replace is effectively a no-operation.  However,
  # the call to `replace` is used ot model the change of the outside world and must be
  # included for analysis tools to appreciate this.
  #
  # replace may only be called during the execution of an operation of a currently installed
  # effect of the same effect type.
  #
  # NYI: BUG: It is currently not enforced that replace is only called during the execution
  # of an operation of a currenlty installed effect of the same effect type.
  #
  public type.replace(e effect.this)
  =>
    replace0 e


  # replace existing effect of type `effect.this` by the new effect value `effect.this`.
  #
  # This is a convenience feature for value type effects for which the type of
  # the effect instance equals the effect type.  `ref` type effects typically have
  # values that may be children of the effect type that are of a different type, so
  # `effect_type.replace new_value` must be used.
  #
  # replace may only be called during the execution of an operation of a currently installed
  # effect of the same effect type.
  #
  public replace
  =>
    effect.this.type.replace effect.this


  # --------------------  aborting code execution  --------------------


  # replace existing effect for type `effect.this` by the new effect value `e`
  # and abort code execution to return to the point where the effect was instated.
  #
  public type.abort(e effect.this) void
  pre
    safety: effect.this.is_instated
    safety: effect.this.env.abortable
  =>
    replace0 e  # NYI: UNDER DEVELOPMENT: Check if this is redundant with backend implementation of abort0!
    abort0 e


  # Abort code execution for the instated effect.this.env and return to the point
  # where the effect was instated.
  #
  public type.abort void
  pre
    safety: effect.this.is_instated
    safety: effect.this.env.abortable
  =>
    effect.this.abort0 effect.this.env


  # does this effect support abort?
  #
  # Redefining this to return `false` helps to detect unexptected calls to
  # `abort` at runtime and ensure that the static analysis finds that the
  # code executed with this effect will always return normally and produce
  # a result. This is used, e.g, in `mutate` to avoid static analysis
  # reporting `panic` as an effect of the use of a local mutate instance.
  #
  public abortable => true


  # abort the current execution and return from the surrounding call to
  # `instate`.
  #
  # NYI: CLEANUP: `return` is the same as `abort`. The term `return` seems
  # common for algebraic effects, but is confusing since it is different to
  # returning from a call. We need to decide to break with algebraic effect
  # jargon (and remove `return`) or to stick with it (and rename `abort` as
  # `return`).
  #
  public type.return void
  pre
    safety: effect.this.is_instated
    safety: effect.this.env.abortable
  =>
    abort


  # --------------------  resource cleanup  --------------------


  # feature that will be called on the instance of this effect when it
  # will be de-instated.
  #
  public finally =>


  # internal feature that will be called on the instance of this effect
  # when it will be de-instated.
  #
  # This is just a trampoline for compiler convenience such that when
  # generating code for the instate0 intrinsic the compiler does
  # not need to care about dynamic binding if the current effect is a
  # `ref`.
  #
  static_finally => finally


  # --------------------  helper features  --------------------


Effect_Call(f () -> R) : Function unit is
  r := option R nil
  redef call =>
    set r := f()

Effect_Call2(f E -> R) : Function unit E is
  r := option R nil
  redef call(e E) =>
    set r := f e
