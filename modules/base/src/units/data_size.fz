# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature units.data_size
#
# -----------------------------------------------------------------------

# units.data_size -- value representing a data_size
#
public data_size(

  public bytes u64
  )
  : property.orderable,
    property.hashable

is

  # this units.data_size in kibibytes, omitting fractional part
  #
  public kib u64 => bytes / byte_unit_iec.kib.in_bytes

  # this units.data_size in kibibytes, including fractional part
  #
  public kib_float f64 => bytes.as_f64 / byte_unit_iec.kib.in_bytes.as_f64

  # this units.data_size in mebibytes, omitting fractional part
  #
  public mib u64 => bytes / byte_unit_iec.mib.in_bytes

  # this units.data_size in mebibytes, including fractional part
  #
  public mib_float f64 => bytes.as_f64 / byte_unit_iec.mib.in_bytes.as_f64

  # this units.data_size in gibibytes, omitting fractional part
  #
  public gib u64 => bytes / byte_unit_iec.gib.in_bytes

  # this units.data_size in gibibytes, including fractional part
  #
  public gib_float f64 => bytes.as_f64 / byte_unit_iec.gib.in_bytes.as_f64

  # this units.data_size in tebibytes, omitting fractional part
  #
  public tib u64 => bytes / byte_unit_iec.tib.in_bytes

  # this units.data_size in tebibytes, including fractional part
  #
  public tib_float f64 => bytes.as_f64 / byte_unit_iec.tib.in_bytes.as_f64

  # this units.data_size in pebibytes, omitting fractional part
  #
  public pib u64 => bytes / byte_unit_iec.pib.in_bytes

  # this units.data_size in pebibytes, including fractional part
  #
  public pib_float f64 => bytes.as_f64 / byte_unit_iec.pib.in_bytes.as_f64

  # this units.data_size in exbibytes, omitting fractional part
  #
  public eib u64 => bytes / byte_unit_iec.eib.in_bytes

  # this units.data_size in exbibytes, including fractional part
  #
  public eib_float f64 => bytes.as_f64 / byte_unit_iec.eib.in_bytes.as_f64

  # this units.data_size in zebibytes, omitting fractional part
  #
  public zib u64 => bytes / byte_unit_iec.zib.in_bytes

  # this units.data_size in zebibytes, including fractional part
  #
  public zib_float f64 => bytes.as_f64 / byte_unit_iec.zib.in_bytes.as_f64

  # this units.data_size in yobibytes, omitting fractional part
  #
  public yib u64 => bytes / byte_unit_iec.yib.in_bytes

  # this units.data_size in yobibytes, including fractional part
  #
  public yib_float f64 => bytes.as_f64 / byte_unit_iec.yib.in_bytes.as_f64

  # this units.data_size in robibytes, omitting fractional part
  #
  public rib u64 => bytes / byte_unit_iec.rib.in_bytes

  # this units.data_size in robibytes, including fractional part
  #
  public rib_float f64 => bytes.as_f64 / byte_unit_iec.rib.in_bytes.as_f64

  # this units.data_size in quebibytes, omitting fractional part
  #
  public qib u64 => bytes / byte_unit_iec.qib.in_bytes

  # this units.data_size in quebibytes, including fractional part
  #
  public qib_float f64 => bytes.as_f64 / byte_unit_iec.qib.in_bytes.as_f64


  # this units.data_size and another one combined
  #
  public infix + (other data_size) data_size
  pre
    safety: bytes +! other.bytes
  =>
    data_size (bytes + other.bytes)


  # this units.data_size minus another units.data_size
  #
  public fixed infix - (other data_size) data_size
  pre
    safety: data_size.this >= other
  =>
    data_size (bytes - other.bytes)


  # this units.data_size multiplied by factor n
  #
  public infix * (n u64) data_size
  pre
    safety: bytes *! n
  =>
    data_size bytes*n


  # this units.data_size multiplied by factor f
  #
  public times(f f64) data_size
  =>
    data_size (bytes.as_f64 * f).as_i64.as_u64


  # this units.data_size divided by units.data_size other, rounding down
  #
  public infix / (other data_size.this) u64
  =>
    bytes / other.bytes

  # create a string representation of this units.data_size. The string representation
  # is not accurate, it is either an integer in the range [10,1023]
  # or a float in the range [1,10) with exactly one fractional digit
  # both are followed by a byte_unit_iec string.
  #
  public redef as_string String =>
    as_string unit_for_as_string


  # create a string representation of this units.data_size using the given unit.
  #
  public as_string(u units.byte_unit_iec) String =>
    n String := if bytes / u.in_bytes >= 10 || !u.smaller.ok
                  $(bytes / u.in_bytes)
                else
                  # add one decimal
                  (bytes.as_f64 / u.in_bytes.as_f64).as_string.pad "0" 3 .substring 0 3

    " "*(max 0 4-n.byte_length) + n + " " + u.short_name


  # Determines the unit to use for as_string, such that the resulting value is in the range [1,1023]
  #
  public unit_for_as_string units.byte_unit_iec =>
    for
      x := units.byte_unit_iec.b, nx.get
      nx := x.larger
    while nx >>? (u -> bytes / u.in_bytes >= 1024)
    else nx >>? (u -> bytes / u.in_bytes > 0) ? nx.val : x


  # total order
  #
  public fixed redef type.lteq(a, b units.data_size) bool =>
    u64.type.lteq a.bytes b.bytes


  # create hash code from a units.data_size
  #
  public redef type.hash_code(d units.data_size.this) u64 =>
    d.bytes

  # This data.size_iec (base 2, 1000 byte = 1 KiB) as data_size.si (base 10, 1000 byte = 1 kB)
  #
  public as_si() data_size.si => data_size.si bytes


  # max value for a units.data_size given in bytes
  public type.max_bytes     u64  => u64.max

  # max value for a units.data_size given in kibibytes
  public type.max_kibibytes u64  => u64.max / byte_unit_iec.b.in_bytes

  # max value for a units.data_size given in mebibytes
  public type.max_mebibytes u64  => u64.max / byte_unit_iec.kib.in_bytes

  # max value for a units.data_size given in gibibytes
  public type.max_gibibytes u64  => u64.max / byte_unit_iec.mib.in_bytes

  # max value for a units.data_size given in tebibytes
  public type.max_tebibytes u64  => u64.max / byte_unit_iec.gib.in_bytes

  # max value for a units.data_size given in pebibytes
  public type.max_pebibytes u64  => u64.max / byte_unit_iec.tib.in_bytes

  # max value for a units.data_size given in exbibytes
  public type.max_exbibytes u64  => u64.max / byte_unit_iec.pib.in_bytes

  # max value for a units.data_size given in zebibytes
  public type.max_zebibytes u64  => u64.max / byte_unit_iec.eib.in_bytes

  # max value for a units.data_size given in yobibytes
  public type.max_yobibytes u64  => u64.max / byte_unit_iec.zib.in_bytes

  # max value for a units.data_size given in robibytes
  public type.max_robibytes u64  => u64.max / byte_unit_iec.yib.in_bytes

  # max value for a units.data_size given in quebibytes
  public type.max_quebibytes u64 => u64.max / byte_unit_iec.rib.in_bytes


  # create units.data_size of n bytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.b (n u64) units.data_size
  pre
    debug: n ≤ max_bytes
  => units.data_size n

  # create units.data_size of n kibibytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.kib (n u64) units.data_size
  pre
    debug: n ≤ max_kibibytes
  => units.data_size n*byte_unit_iec.kib.in_bytes

  # create units.data_size of n mebibytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.mib (n u64) units.data_size
  pre
    debug: n ≤ max_mebibytes
  => units.data_size n*byte_unit_iec.mib.in_bytes

  # create units.data_size of n gibibytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.gib (n u64) units.data_size
  pre
    debug: n ≤ max_gibibytes
  => units.data_size n*byte_unit_iec.gib.in_bytes

  # create units.data_size of n tebibytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.tib (n u64) units.data_size
  pre
    debug: n ≤ max_tebibytes
  => units.data_size n*byte_unit_iec.tib.in_bytes

  # create units.data_size of n pebibytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.pib (n u64) units.data_size
  pre
    debug: n ≤ max_pebibytes
  => units.data_size n*byte_unit_iec.pib.in_bytes

  # create units.data_size of n exbibytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.eib (n u64) units.data_size
  pre
    debug: n ≤ max_exbibytes
  => units.data_size n*byte_unit_iec.eib.in_bytes

  # create units.data_size of n zebibytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.zib (n u64) units.data_size
  pre
    debug: n ≤ max_zebibytes
  => units.data_size n*byte_unit_iec.zib.in_bytes

  # create units.data_size of n yobibytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.yib (n u64) units.data_size
  pre
    debug: n ≤ max_yobibytes
  => units.data_size n*byte_unit_iec.yib.in_bytes

  # create units.data_size of n robibytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.rib (n u64) units.data_size
  pre
    debug: n ≤ max_robibytes
  => units.data_size n*byte_unit_iec.rib.in_bytes

  # create units.data_size of n quebibytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.qib (n u64) units.data_size
  pre
    debug: n ≤ max_quebibytes
  => units.data_size n*byte_unit_iec.qib.in_bytes


  # the zero units.data_size, representing a zero bytes
  #
  public type.zero units.data_size => units.data_size 0


  # the maximum units.data_size
  #
  public type.max units.data_size => units.data_size.b units.data_size.max_bytes
