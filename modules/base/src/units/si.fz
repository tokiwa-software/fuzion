# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature data_size.si
#
# -----------------------------------------------------------------------

# data_size.si -- value representing a si
#
public si(

  public bytes u64
  )
  : property.orderable,
    property.hashable

is

  # this data_size.si in kilobytes, omitting fractional part
  #
  public kb u64 => bytes / byte_unit_si.kb.in_bytes

  # this data_size.si in kilobytes, including fractional part
  #
  public kb_float f64 => bytes.as_f64 / byte_unit_si.kb.in_bytes.as_f64

  # this data_size.si in megabytes, omitting fractional part
  #
  public mb u64 => bytes / byte_unit_si.mb.in_bytes

  # this data_size.si in megabytes, including fractional part
  #
  public mb_float f64 => bytes.as_f64 / byte_unit_si.mb.in_bytes.as_f64

  # this data_size.si in gigabytes, omitting fractional part
  #
  public gb u64 => bytes / byte_unit_si.gb.in_bytes

  # this data_size.si in gigabytes, including fractional part
  #
  public gb_float f64 => bytes.as_f64 / byte_unit_si.gb.in_bytes.as_f64

  # this data_size.si in terabytes, omitting fractional part
  #
  public tb u64 => bytes / byte_unit_si.tb.in_bytes

  # this data_size.si in terabytes, including fractional part
  #
  public tb_float f64 => bytes.as_f64 / byte_unit_si.tb.in_bytes.as_f64

  # this data_size.si in petabytes, omitting fractional part
  #
  public pb u64 => bytes / byte_unit_si.pb.in_bytes

  # this data_size.si in petabytes, including fractional part
  #
  public pb_float f64 => bytes.as_f64 / byte_unit_si.pb.in_bytes.as_f64

  # this data_size.si in exabytes, omitting fractional part
  #
  public eb u64 => bytes / byte_unit_si.eb.in_bytes

  # this data_size.si in exabytes, including fractional part
  #
  public eb_float f64 => bytes.as_f64 / byte_unit_si.eb.in_bytes.as_f64

  # this data_size.si in zettabytes, omitting fractional part
  #
  public zb u64 => bytes / byte_unit_si.zb.in_bytes

  # this data_size.si in zettabytes, including fractional part
  #
  public zb_float f64 => bytes.as_f64 / byte_unit_si.zb.in_bytes.as_f64

  # this data_size.si in yottabytes, omitting fractional part
  #
  public yb u64 => bytes / byte_unit_si.yb.in_bytes

  # this data_size.si in yottabytes, including fractional part
  #
  public yb_float f64 => bytes.as_f64 / byte_unit_si.yb.in_bytes.as_f64

  # this data_size.si in ronnabytes, omitting fractional part
  #
  public rb u64 => bytes / byte_unit_si.rb.in_bytes

  # this data_size.si in ronnabytes, including fractional part
  #
  public rb_float f64 => bytes.as_f64 / byte_unit_si.rb.in_bytes.as_f64

  # this data_size.si in quettabytes, omitting fractional part
  #
  public qb u64 => bytes / byte_unit_si.qb.in_bytes

  # this data_size.si in quettabytes, including fractional part
  #
  public qb_float f64 => bytes.as_f64 / byte_unit_si.qb.in_bytes.as_f64


  # this data_size.si and another one combined
  #
  public infix + (other si) si
  pre
    safety: bytes +! other.bytes
  =>
    si (bytes + other.bytes)


  # this data_size.si minus another data_size.si
  #
  public fixed infix - (other si) si
  pre
    safety: si.this >= other
  =>
    si (bytes - other.bytes)


  # this data_size.si multiplied by factor n
  #
  public infix * (n u64) si
  pre
    safety: bytes *! n
  =>
    si bytes*n


  # this data_size.si multiplied by factor f
  #
  public times(f f64) si
  =>
    si (bytes.as_f64 * f).as_i64.as_u64


  # this data_size.si divided by data_size.si other, rounding down
  #
  public infix / (other si.this) u64
  =>
    bytes / other.bytes

  # create a string representation of this data_size.si. The string representation
  # is not accurate, it is either an integer in the range [10,999]
  # or a float in the range [1,10) with exactly one fractional digit
  # both are followed by a byte_unit_si string.
  #
  public redef as_string String =>
    as_string unit_for_as_string


  # create a string representation of this data_size.si using the given unit.
  #
  public as_string(u data_size.byte_unit_si) String =>
    n String := if bytes / u.in_bytes >= 10 || !u.smaller.ok
                  $(bytes / u.in_bytes)
                else
                  # add one decimal
                  (bytes.as_f64 / u.in_bytes.as_f64).as_string.pad "0" 3 .substring 0 3

    " "*(max 0 4-n.byte_length) + n + " " + u.short_name


  # Determines the unit to use for as_string, such that the resulting value is is in the range [1,999]
  #
  public unit_for_as_string data_size.byte_unit_si =>
    for
      x := data_size.byte_unit_si.b, nx.get
      nx := x.larger
    while nx >>? (u -> bytes / u.in_bytes >= 1E3)
    else nx >>? (u -> bytes / u.in_bytes > 0) ? nx.val : x

  # This data_size.si (base 10, 1000 byte = 1 kB) as data_size.iec (base 2, 1000 byte = 1 KiB)
  #
  public as_iec() data_size.iec => data_size.iec bytes


  # total order
  #
  public fixed redef type.lteq(a, b data_size.si) bool =>
    u64.type.lteq a.bytes b.bytes


  # create hash code from a data_size.si
  #
  public redef type.hash_code(d data_size.si.this) u64 =>
    d.bytes


  # max value for a data_size.si given in bytes
  public type.max_bytes       u64 => u64.max

  # max value for a data_size.si given in kilobytes
  public type.max_kilobytes   u64 => u64.max / byte_unit_si.b.in_bytes

  # max value for a data_size.si given in megabytes
  public type.max_megabytes   u64 => u64.max / byte_unit_si.kb.in_bytes

  # max value for a data_size.si given in gigabytes
  public type.max_gigabytes   u64 => u64.max / byte_unit_si.mb.in_bytes

  # max value for a data_size.si given in terabytes
  public type.max_terabytes   u64 => u64.max / byte_unit_si.gb.in_bytes

  # max value for a data_size.si given in petabytes
  public type.max_petabytes   u64 => u64.max / byte_unit_si.tb.in_bytes

  # max value for a data_size.si given in exabytes
  public type.max_exabytes    u64 => u64.max / byte_unit_si.pb.in_bytes

  # max value for a data_size.si given in zettabytes
  public type.max_zettabytes  u64 => u64.max / byte_unit_si.eb.in_bytes

  # max value for a data_size.si given in yottabytes
  public type.max_yottabytes  u64 => u64.max / byte_unit_si.zb.in_bytes

  # max value for a data_size.si given in ronnabytes
  public type.max_ronnabytes  u64 => u64.max / byte_unit_si.yb.in_bytes

  # max value for a data_size.si given in quettabytes
  public type.max_quettabytes u64 => u64.max / byte_unit_si.rb.in_bytes


  # create data_size.si of n bytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.b (n u64) data_size.si
  pre
    debug: n ≤ max_bytes
  => data_size.si n

  # create data_size.si of n kilobytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.kb (n u64) data_size.si
  pre
    debug: n ≤ max_kilobytes
  => data_size.si n*byte_unit_si.kb.in_bytes

  # create data_size.si of n megabytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.mb (n u64) data_size.si
  pre
    debug: n ≤ max_megabytes
  => data_size.si n*byte_unit_si.mb.in_bytes

  # create data_size.si of n gigabytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.gb (n u64) data_size.si
  pre
    debug: n ≤ max_gigabytes
  => data_size.si n*byte_unit_si.gb.in_bytes

  # create data_size.si of n terabytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.tb (n u64) data_size.si
  pre
    debug: n ≤ max_terabytes
  => data_size.si n*byte_unit_si.tb.in_bytes

  # create data_size.si of n petabytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.pb (n u64) data_size.si
  pre
    debug: n ≤ max_petabytes
  => data_size.si n*byte_unit_si.pb.in_bytes

  # create data_size.si of n exabytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.eb (n u64) data_size.si
  pre
    debug: n ≤ max_exabytes
  => data_size.si n*byte_unit_si.eb.in_bytes

  # create data_size.si of n zettabytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.zb (n u64) data_size.si
  pre
    debug: n ≤ max_zettabytes
  => data_size.si n*byte_unit_si.zb.in_bytes

  # create data_size.si of n yottabytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.yb (n u64) data_size.si
  pre
    debug: n ≤ max_yottabytes
  => data_size.si n*byte_unit_si.yb.in_bytes

  # create data_size.si of n ronnabytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.rb (n u64) data_size.si
  pre
    debug: n ≤ max_ronnabytes
  => data_size.si n*byte_unit_si.rb.in_bytes

  # create data_size.si of n quettabytes
  #
  # NYI: Turn this into a 'postfix' call, see https://fuzion-lang.dev/design/postfix_calls
  #
  public type.qb (n u64) data_size.si
  pre
    debug: n ≤ max_quettabytes
  => data_size.si n*byte_unit_si.qb.in_bytes


  # the zero data_size.si, representing a zero bytes
  #
  public type.zero data_size.si => data_size.si 0


  # the maximum data_size.si
  #
  public type.max data_size.si => data_size.si.b data_size.si.max_bytes
