# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature time.date_time
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------

# Represents a date and a time in the Gregorian calendar, without any specification of
# a time zone or reference point.
#
public date_time(public year, month, day, hour, minute, second, nano_second i32) : property.orderable
pre
  debug: 1 ≤ month ≤ 12
  debug: is_valid_date year month day
  debug: 0 ≤ hour ≤ 23
  debug: 0 ≤ minute ≤ 59
  debug: 0 ≤ second ≤ 60 # possible leap seconds
  debug: 0 ≤ nano_second ≤ 1E9
is

  # the millisecond of this datetime
  #
  public milli_second i32
  post
    debug: result ≥ 0 & result ≤ 999
  =>
    # NYI: BUG: wrong! we should then not expose nano_second
    nano_second / 1E6


  year_as_string => year.as_string 4 10
  month_as_string => date_time.this.month.as_string 2 10
  day_as_string => day.as_string 2 10
  hour_as_string => hour.as_string 2 10
  minute_as_string => minute.as_string 2 10
  second_as_string => second.as_string 2 10
  milli_second_as_string => milli_second.as_string 3 10
  nano_second_as_string => nano_second.as_string 9 10


  # ISO 8601 string for this datetime
  # example: 2018-09-14T23:59:59.079
  #
  public redef as_string String =>
    "$year_as_string-$month_as_string-$day_as_string" +
      "T$hour_as_string:$minute_as_string:$second_as_string.$milli_second_as_string"



  # ISO 8601 string for this datetime
  # example: 2018-09-14T23:59:59.079
  #
  public as_string(p time.precision) String =>
    match p
      time.pyear         =>  "$year_as_string"
      time.pmonth        =>  "$year_as_string-$month_as_string"
      time.pday          =>  "$year_as_string-$month_as_string-$day_as_string"
      time.phour         => ("$year_as_string-$month_as_string-$day_as_string" +
                              "T$hour_as_string")
      time.pminute       => ("$year_as_string-$month_as_string-$day_as_string" +
                              "T$hour_as_string:$minute_as_string")
      time.psecond       => ("$year_as_string-$month_as_string-$day_as_string" +
                              "T$hour_as_string:$minute_as_string:$second_as_string")
      time.pmilli_second => ("$year_as_string-$month_as_string-$day_as_string" +
                              "T$hour_as_string:$minute_as_string:$second_as_string.$milli_second_as_string")
      time.pnano_second  => ("$year_as_string-$month_as_string-$day_as_string" +
                              "T$hour_as_string:$minute_as_string:$second_as_string.$nano_second_as_string")


  # # NYI
  # infix + (other time.duration) date_time is

  # infix - (other date_time) time.duration is
  # infix - (other time.duration) date_time is

  # as_string(f date_time_format, local/time_zone) String is
  # ...


  # returns an array containing the year, the day in the year, hour, minute,
  # second, and nano_second of this date time
  #
  # internal helper feature
  #
  args_in_order => [year, month, day, hour, minute, second, nano_second]


  # 0 = Sunday, 1 = Monday, etc.
  #
  # source: https://c-faq.com/misc/zeller.html
  # original code by: Tomohiko Sakamoto
  #
  public day_of_week i32 =>
    t := [0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4]
    y := year - (if month < 3 then 1 else 0)
    (y + y/4 - y/100 + y/400 + t[month-1] + day) % 7



  # create a date_time from given seconds since 1970-01-01T00:00:00
  #
  # NOTE: this does not adjust for leap seconds
  #
  public type.from_seconds(n u64) time.date_time
    pre debug    : n < 3E11 # this restriction is arbitrary (year 11476)
    post analysis: result >= (time.date_time 1970 1 1 0 0 0 0)
  =>
    year, r0 :=
      for rest := n, rest - seconds_in_year
          y := 1970, y+1
          seconds_in_year := (u64 60)*60*24*(time.is_leap_year y ? (u64 366) : (u64 365))
      while rest >= seconds_in_year
      else
        (y, rest)

    month, r1 :=
      for rest := r0, rest - seconds_in_month
          m := 1, m+1
          seconds_in_month := (u64 60)*60*24*(time.days_in_month year m).as_u64
      while rest >= seconds_in_month
      else
        (m, rest)

    seconds_in_day := (u64 60)*60*24
    day, r2 := (r1 / seconds_in_day + 1, r1 % seconds_in_day)
    seconds_in_hour := (u64 60)*60
    hour, r3 := (r2 / seconds_in_hour, r2 % seconds_in_hour)
    seconds_in_minute := u64 60
    minute, second := (r3 / seconds_in_minute, r3 % seconds_in_minute)

    time.date_time year month day.as_i32 hour.as_i32 minute.as_i32 second.as_i32 0



  # defines an equality relation for date time
  #
  public redef type.equality(a, b date_time.this) bool =>
    a.nano_second = b.nano_second &
     a.year = b.year &
     a.month = b.month &
     a.day = b.day &
     a.hour = b.hour &
     a.minute = b.minute &
     a.second = b.second


  # defines a partial order for date time
  #
  public redef type.lteq(a, b date_time.this) bool =>
    ternary_compare trit =>
      a.args_in_order
       .zip b.args_in_order tuple
       .reduce trit.unknown r,t->
         if t.0 = t.1
           trit.unknown
         else if t.0 < t.1
           abort trit.yes
         else
           abort trit.no

    ternary_compare.is_yes_or_unknown


# is the given year a leap year?
#
is_leap_year(year i32) =>
  (year % 4 = 0 & year % 100 != 0) |
    ((year % 100 = 0) & (year % 400 = 0))


# how many days does february have in the given year?
#
days_in_february(year i32) =>
  if is_leap_year year then 29 else 28


# the days in the months of the year
# starting at january, february, ..., december
#
days_in_months(year i32) =>
  [31, days_in_february year, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]


# how many days does a given month of a given year have
#
days_in_month(year, month i32) =>
  (days_in_months year)[month - 1]


# is the given date valid?
#
public is_valid_date(year, month, day i32) bool
  pre
    debug: 1 ≤ month ≤ 12
=>
  1 ≤ day ≤ days_in_month year month
