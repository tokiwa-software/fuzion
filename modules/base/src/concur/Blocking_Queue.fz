# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature Blocking_Queue
#
# -----------------------------------------------------------------------


# state of the blocking queue
#
bqstate(T type, is_closed bool, data array T) is


# NYI: replace by better queue implementation, e.g. https://arxiv.org/pdf/2305.07229
module Blocking_Queue(T type) ref is

  # the state of this queue
  #
  # atomic just for convenience
  #
  # accessed only by one thread at a time
  #
  s := concur.atomic (bqstate T) .new (bqstate T false [])


  # condition for synchronization
  #
  cnd := concur.sync.condition.new.val # NYI: error handling


  module close =>
    cnd.synchronized ()->
      c := s.read
      s.write (bqstate true c.data)
      check cnd.broadcast


  # enqueue an element
  # if queue is already closed, returns false
  # otherwise enqueues the element and returns true
  #
  module enqueue(el T) bool =>
    cnd.synchronized ()->
      c := s.read
      if c.is_closed
        false
      else
        s.write (bqstate false (c.data.put c.data.length el))
        # signal a waiting thread to pick up the work
        check cnd.signal
        true


  # dequeue an element
  # returns nil, if queue is closed and empty
  # otherwise returns the dequeued element
  #
  module dequeue option T =>

    depleted is
    retry is

    for res := {
        cnd.synchronized (choice T depleted retry) ()->
          c := s.read
          if c.data.is_empty
            if c.is_closed
              depleted
            else
              check cnd.wait
              retry
          else
            s.write (bqstate c.is_closed (c.data.drop 1 .as_array))
            c.data[0]
              }
    while res ? retry => true | * => false
    else
      match res
        depleted => nil
        t T => t
        retry => panic "Illegal state in Blocking_Queue, bug!"

