# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature Finger_Tree
#
# -----------------------------------------------------------------------

# https://www.cs.ox.ac.uk/ralf.hinze/publications/FingerTrees.pdf
# https://github.com/ledbutter/CSharpFingerTree

private:public Finger_Tree(T type) ref : Sequence T is
  public redef as_list list T => as_sequence.flat_map id .as_list
  public redef finite trit => trit.yes
  as_sequence Sequence (Sequence T) => abstract

  public prepend(c Sequence T) container.Finger_Tree T => abstract
  public append (c Sequence T) container.Finger_Tree T => abstract


  left  option (Sequence T, container.Finger_Tree T) => abstract
  right option (container.Finger_Tree T, Sequence T) => abstract
  merge(ft container.Finger_Tree T) container.Finger_Tree T => abstract
  app2(s Sequence (Sequence T), ft container.Finger_Tree T) container.Finger_Tree T => abstract

  public type.empty container.Finger_Tree T => container.empty T

  as_deep deep T => panic "bug!"



empty(T type) : container.Finger_Tree T is
  public redef count i32 => 0
  redef as_sequence Sequence (Sequence T) => []
  public redef prepend(c Sequence T) container.Finger_Tree T => single T c
  public redef append (c Sequence T) container.Finger_Tree T => single T c
  redef left  option (Sequence T, container.Finger_Tree T) => nil
  redef right option (container.Finger_Tree T, Sequence T) => nil
  redef merge(ft container.Finger_Tree T) container.Finger_Tree T => ft
  redef app2(s Sequence (Sequence T), ft container.Finger_Tree T) container.Finger_Tree T =>
    for r := ft, r.prepend i
        i in s.reverse
    else
      r



single(T type, a Sequence T) : container.Finger_Tree T is
  public redef count i32 => a.count
  redef as_sequence Sequence (Sequence T) => [a]
  public redef prepend(c Sequence T) container.Finger_Tree T => deep (digit [c]) (empty T) (digit [a])
  public redef append (c Sequence T) container.Finger_Tree T => deep (digit [a]) (empty T) (digit [c])
  redef left  option (Sequence T, container.Finger_Tree T) => (a, (container.Finger_Tree T).empty)
  redef right option (container.Finger_Tree T, Sequence T) => ((container.Finger_Tree T).empty, a)
  redef merge(ft container.Finger_Tree T) container.Finger_Tree T =>
    ft.prepend a
  redef app2(s Sequence (Sequence T), ft container.Finger_Tree T) container.Finger_Tree T =>
    for r := ft, r.prepend i
        i in s.reverse
    else
      r.prepend a



deep(T type, a digit T, ft container.Finger_Tree T, c digit T) : container.Finger_Tree T is
  cnt := a.count + ft.count + c.count
  public redef count i32 => cnt
  redef as_sequence Sequence (Sequence T) => [a.d, ft.as_sequence, c.d].flat_map id
  public redef prepend(c Sequence T) container.Finger_Tree T =>
    if a.d.count = 4
      deep (digit [prepend.this.c, a.d[0]]) (ft.prepend ((a.d.drop 1).flat_map id)) deep.this.c
    else
      deep (digit ([[prepend.this.c], a.d].flat_map id)) ft deep.this.c


  public redef append (c Sequence T) container.Finger_Tree T =>
    if deep.this.c.d.count = 4
      deep a (ft.append ((deep.this.c.d.take 3).flat_map id)) (digit [deep.this.c.d[3], append.this.c])
    else
      deep a ft (digit ([deep.this.c.d, [append.this.c]].flat_map id))
  redef left  option (Sequence T, container.Finger_Tree T) =>
    if a.d.count = 1
      match ft.left
        nil => (a.d[0], from_sequence c.d)
        l (Sequence T, container.Finger_Tree T) =>
          x,y := l
          (a.d[0], id (container.Finger_Tree T) (deep (digit [x]) y c))
    else
      (a.d[0], id (container.Finger_Tree T) (deep (digit (a.d.drop 1)) ft c))
  redef right option (container.Finger_Tree T, Sequence T) =>
    if c.d.count = 1
      match ft.right
        nil => (from_sequence c.d, c.d[count-1])
        r (container.Finger_Tree T, Sequence T) =>
          x,y := r
          (id (container.Finger_Tree T) (deep a x (digit [y])), c.d[count-1])
    else
      (id (container.Finger_Tree T) (deep a ft (digit (c.d.take c.d.count-1))), c.d[count-1])
  redef merge(ft container.Finger_Tree T) container.Finger_Tree T =>
    app2 [] merge.this.ft
  redef app2(s Sequence (Sequence T), ft container.Finger_Tree T) container.Finger_Tree T =>
    if app2.this.ft.count = 0
      for r container.Finger_Tree T := deep.this, r.append i
          i in s
      else
        r
    else if app2.this.ft.left.val.1.count = 0
      for r container.Finger_Tree T := deep.this, r.append i
          i in s
      else
        r.append app2.this.ft.left.val.0
    else
      d := as_deep
      deep a (deep.this.app2 ([deep.this.c.d, s, d.a.d].flat_map id) d.ft) d.c
  from_sequence(seq Sequence (Sequence T)) =>
    for r := container.Finger_Tree T .empty, r.append i
        i in seq
    else
      r
  redef as_deep deep T =>
    deep a ft c



digit(T type, d Sequence (Sequence T)) : property.countable
  pre
    debug: 1 <= d.count <= 4
is
  cnt := d.map x->x.count .sum
  public redef count i32 => cnt
