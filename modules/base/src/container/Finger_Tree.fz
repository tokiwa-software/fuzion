# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature Finger_Tree
#
# -----------------------------------------------------------------------


#
#
# The paper introducing the datastructure: https://www.cs.ox.ac.uk/ralf.hinze/publications/FingerTrees.pdf
# The implementation that was used as inspiration for this port: https://github.com/ledbutter/CSharpFingerTree
#
private:public Finger_Tree(T type) ref : Sequence T is

  # the Finger_Tree as a list
  #
  public redef as_list list T => as_sequence.flat_map id .as_list

  # is this sequence known to be finite?  For infinite sequences, features like
  # count diverge.
  #
  public redef finite trit => trit.yes
  as_sequence Sequence (Sequence T) => abstract

  public prepend(seq Sequence T) container.Finger_Tree T => abstract
  public append (seq Sequence T) container.Finger_Tree T => abstract


  left  option (Sequence T, container.Finger_Tree T) => abstract
  right option (container.Finger_Tree T, Sequence T) => abstract
  merge(ft container.Finger_Tree T) container.Finger_Tree T => abstract
  app2(seq Sequence (Sequence T), ft container.Finger_Tree T) container.Finger_Tree T => abstract

  public type.empty container.Finger_Tree T => container.empty T

  as_deep deep T => panic "bug!"


  # is this Sequence known to be array backed? If so, this means that operations
  # like index[] are fast.
  #
  public redef is_array_backed bool => false


  # check if argument is a valid index in this array.
  #
  # Unlike for general Sequences, this performs in O(1).
  #
  public redef is_valid_index(i idx) bool => 0 â‰¤ i.as_i32 < count


  # the nth element in the sequence, must exist
  #
  public redef nth(n i32) option T => abstract

  # NYI: UNDER DEVELOPMENT index/nth, split, reverse


# an empty finger tree
#
empty(T type) : container.Finger_Tree T is
  public redef count i32 => 0
  redef as_sequence Sequence (Sequence T) => []
  public redef prepend(seq Sequence T) container.Finger_Tree T => single T seq
  public redef append (seq Sequence T) container.Finger_Tree T => single T seq
  redef left  option (Sequence T, container.Finger_Tree T) => nil
  redef right option (container.Finger_Tree T, Sequence T) => nil
  redef merge(ft container.Finger_Tree T) container.Finger_Tree T => ft
  redef app2(seq Sequence (Sequence T), ft container.Finger_Tree T) container.Finger_Tree T =>
    for r := ft, r.prepend i
        i in seq.reverse
    else
      r
  public redef nth(n i32) option T => nil


# a finger tree with only one item
#
single(T type, data Sequence T) : container.Finger_Tree T is
  public redef count i32 => data.count
  redef as_sequence Sequence (Sequence T) => [data]
  public redef prepend(seq Sequence T) container.Finger_Tree T => deep (hand [seq]) (empty T) (hand [data])
  public redef append (seq Sequence T) container.Finger_Tree T => deep (hand [data]) (empty T) (hand [seq])
  redef left  option (Sequence T, container.Finger_Tree T) => (data, (container.Finger_Tree T).empty)
  redef right option (container.Finger_Tree T, Sequence T) => ((container.Finger_Tree T).empty, data)
  redef merge(ft container.Finger_Tree T) container.Finger_Tree T =>
    ft.prepend data
  redef app2(seq Sequence (Sequence T), ft container.Finger_Tree T) container.Finger_Tree T =>
    for r := ft, r.prepend i
        i in seq.reverse
    else
      r.prepend data
  public redef nth(n i32) option T => data.nth n


# a deep finger tree
#
deep(T type, lft hand T, ft container.Finger_Tree T, rght hand T) : container.Finger_Tree T is
  cnt := lft.count + ft.count + rght.count
  public redef count i32 => cnt
  redef as_sequence Sequence (Sequence T) => [lft.finger, ft.as_sequence, rght.finger].flat_map id
  public redef prepend(seq Sequence T) container.Finger_Tree T =>
    if lft.finger.count = 4
      deep (hand [seq, lft.finger[0]]) (ft.prepend ((lft.finger.drop 1).flat_map id)) rght
    else
      deep (lft.prepend seq) ft rght
  public redef append (seq Sequence T) container.Finger_Tree T =>
    if rght.finger.count = 4
      deep lft (ft.append ((rght.finger.take 3).flat_map id)) (hand [rght.finger[3], seq])
    else
      deep lft ft (rght.append seq)
  redef left  option (Sequence T, container.Finger_Tree T) =>
    if lft.finger.count = 1
      match ft.left
        nil => (lft.finger[0], from_sequence rght.finger)
        l (Sequence T, container.Finger_Tree T) =>
          x,y := l
          (lft.finger[0], id (container.Finger_Tree T) (deep (hand [x]) y rght))
    else
      (lft.finger[0], id (container.Finger_Tree T) (deep lft.drop_first ft rght))
  redef right option (container.Finger_Tree T, Sequence T) =>
    if rght.finger.count = 1
      match ft.right
        nil => (from_sequence rght.finger, rght.finger[count-1])
        r (container.Finger_Tree T, Sequence T) =>
          x,y := r
          (id (container.Finger_Tree T) (deep lft x (hand [y])), rght.finger[count-1])
    else
      (id (container.Finger_Tree T) (deep lft ft rght.drop_last), rght.finger[count-1])
  redef merge(ft0 container.Finger_Tree T) container.Finger_Tree T =>
    app2 [] ft0
  redef app2(seq Sequence (Sequence T), ft0 container.Finger_Tree T) container.Finger_Tree T =>
    if ft0.count = 0
      for r container.Finger_Tree T := deep.this, r.append i
          i in seq
      else
        r
    else if ft0.left.val.1.count = 0
      for r container.Finger_Tree T := deep.this, r.append i
          i in seq
      else
        r.append ft0.left.val.0
    else
      d := as_deep
      deep lft (deep.this.app2 ([rght.finger, seq, d.lft.finger].flat_map id) d.ft) d.rght
  from_sequence(seq Sequence (Sequence T)) =>
    for r := container.Finger_Tree T .empty, r.append i
        i in seq
    else
      r
  redef as_deep deep T =>
    deep lft ft rght
  public redef nth(n i32) option T =>
    if n < lft.count
      lft.nth n
    else if n < lft.count+ft.count
      ft.nth (n-lft.count)
    else
      rght.nth (n-lft.count-ft.count)



# this is called digit in the paper
#
hand(T type, finger Sequence (Sequence T)) : property.countable
  pre
    debug 2 : 1 <= finger.count <= 4
is
  cnt := finger.map x->x.count .sum
  public redef count i32 => cnt


  drop_first
    pre
      debug 2 : finger.count > 1
  =>
    hand (finger.drop 1)


  drop_last
    pre
      debug 2 : finger.count > 1
  =>
    hand (finger.take finger.count-1)


  prepend(seq Sequence T)
    pre
      debug 2 : finger.count < 4
  =>
    hand ([[seq], finger].flat_map id)


  append(seq Sequence T)
    pre
      debug 2 : finger.count < 4
  =>
    hand ([finger, [seq]].flat_map id)


  public nth(n i32) option T =>
    for idx := n, idx-f.count
        f in finger
    until f.is_valid_index idx
      f[idx]
    else
      nil
