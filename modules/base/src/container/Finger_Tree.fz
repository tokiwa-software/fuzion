# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature Finger_Tree
#
# -----------------------------------------------------------------------


#
# The paper introducing the datastructure: https://www.cs.ox.ac.uk/ralf.hinze/publications/FingerTrees.pdf
# The implementation that was used as inspiration for this port: https://github.com/ledbutter/CSharpFingerTree
#
# NYI: UNDER DEVELOPMENT: split0, reverse
#
private:public Finger_Tree(T type) ref : Sequence T is

  # the Finger_Tree as a list
  #
  public redef as_list list T => as_sequence.flat_map id .as_list

  # is this sequence known to be finite?  For infinite sequences, features like
  # count diverge.
  #
  public redef finite trit => trit.yes
  as_sequence Sequence (Sequence T) => abstract

  module prepend(seq Sequence T) container.Finger_Tree T => abstract
  append (seq Sequence T) container.Finger_Tree T => abstract

  left  option (Sequence T, container.Finger_Tree T) => abstract
  right option (container.Finger_Tree T, Sequence T) => abstract
  merge(ft container.Finger_Tree T) container.Finger_Tree T => abstract
  app2(seq Sequence (Sequence T), ft container.Finger_Tree T) container.Finger_Tree T => abstract

  public type.empty container.Finger_Tree T => container.empty T

  as_deep deep T => panic "bug!"

  public redef concat (s Sequence T) Sequence T =>
    append s.as_array_backed


  # is this Sequence known to be array backed? If so, this means that operations
  # like index[] are fast.
  #
  public redef is_array_backed bool => false


  # check if argument is a valid index in this array.
  #
  # Unlike for general Sequences, this performs in O(1).
  #
  public redef is_valid_index(i idx) bool => 0 â‰¤ i.as_i32 < count


  # the nth element in the sequence, must exist
  #
  public redef nth(n i32) option T => abstract


  public redef take (n i32) Sequence T => abstract
  public redef drop (n i32) Sequence T => abstract



# an empty finger tree
#
empty(T type) : container.Finger_Tree T is
  public redef count i32 => 0
  redef as_sequence Sequence (Sequence T) => []
  module redef prepend(seq Sequence T) container.Finger_Tree T => single T seq
  redef append (seq Sequence T) container.Finger_Tree T => single T seq
  redef left  option (Sequence T, container.Finger_Tree T) => nil
  redef right option (container.Finger_Tree T, Sequence T) => nil
  redef merge(ft container.Finger_Tree T) container.Finger_Tree T => ft
  redef app2(seq Sequence (Sequence T), ft container.Finger_Tree T) container.Finger_Tree T =>
    for r := ft, r.prepend i
        i in seq.reverse
    else
      r
  public redef nth(n i32) option T => nil
  module redef as_finger_tree option (container.Finger_Tree T) => container.empty T
  public redef take (n i32) Sequence T => empty.this
  public redef drop (n i32) Sequence T => empty.this


# a finger tree with only one item
#
single(T type, data Sequence T) : container.Finger_Tree T is
  public redef count i32 => data.count
  redef as_sequence Sequence (Sequence T) => [data]
  module redef prepend(seq Sequence T) container.Finger_Tree T => deep (container.hand [seq]) (empty T) (container.hand [data])
  redef append (seq Sequence T) container.Finger_Tree T => deep (container.hand [data]) (empty T) (container.hand [seq])
  redef left  option (Sequence T, container.Finger_Tree T) => (data, (container.Finger_Tree T).empty)
  redef right option (container.Finger_Tree T, Sequence T) => ((container.Finger_Tree T).empty, data)
  redef merge(ft container.Finger_Tree T) container.Finger_Tree T => ft.prepend data
  redef app2(seq Sequence (Sequence T), ft container.Finger_Tree T) container.Finger_Tree T =>
    for r := ft, r.prepend i
        i in seq.reverse
    else
      r.prepend data
  public redef nth(n i32) option T => data.nth n
  module redef as_finger_tree option (container.Finger_Tree T) => container.single data
  public redef take (n i32) Sequence T => single (data.take n)
  public redef drop (n i32) Sequence T => single (data.drop n)


# a deep finger tree
#
deep(T type, lft container.hand T, ft container.Finger_Tree T, rght container.hand T) : container.Finger_Tree T is
  cnt := lft.count + ft.count + rght.count
  public redef count i32 => cnt
  redef as_sequence Sequence (Sequence T) => [lft.finger, ft.as_sequence, rght.finger].flat_map id
  module redef prepend(seq Sequence T) container.Finger_Tree T =>
    if lft.finger.count = 4
      deep (container.hand [seq, lft.finger[0]]) (ft.prepend ((lft.finger.drop 1).flat_map id).as_array_backed) rght
    else
      deep (lft.prepend seq) ft rght
  redef append (seq Sequence T) container.Finger_Tree T =>
    if rght.finger.count = 4
      deep lft (ft.append ((rght.finger.take 3).flat_map id).as_array_backed) (container.hand [rght.finger[3], seq])
    else
      deep lft ft (rght.append seq)
  redef left  option (Sequence T, container.Finger_Tree T) =>
    if lft.finger.count = 1
      match ft.left
        nil => (lft.finger[0], from_sequence rght.finger)
        l (Sequence T, container.Finger_Tree T) =>
          x,y := l
          (lft.finger[0], id (container.Finger_Tree T) (deep (container.hand [x]) y rght))
    else
      (lft.finger[0], id (container.Finger_Tree T) (deep lft.drop_first ft rght))
  redef right option (container.Finger_Tree T, Sequence T) =>
    if rght.finger.count = 1
      match ft.right
        nil => (from_sequence rght.finger, rght.finger[count-1])
        r (container.Finger_Tree T, Sequence T) =>
          x,y := r
          (id (container.Finger_Tree T) (deep lft x (container.hand [y])), rght.finger[count-1])
    else
      (id (container.Finger_Tree T) (deep lft ft rght.drop_last), rght.finger[count-1])
  redef merge(ft0 container.Finger_Tree T) container.Finger_Tree T =>
    app2 [] ft0
  redef app2(seq Sequence (Sequence T), ft0 container.Finger_Tree T) container.Finger_Tree T =>
    if ft0.count = 0
      for r container.Finger_Tree T := deep.this, r.append i
          i in seq
      else
        r
    else if ft0.left.val.1.count = 0
      for r container.Finger_Tree T := deep.this, r.append i
          i in seq
      else
        r.append ft0.left.val.0
    else
      d := as_deep
      deep lft (deep.this.app2 ([rght.finger, seq, d.lft.finger].flat_map id).as_array_backed d.ft) d.rght
  from_sequence(seq Sequence (Sequence T)) =>
    for r := container.Finger_Tree T .empty, r.append i
        i in seq
    else
      r
  redef as_deep deep T =>
    deep lft ft rght
  public redef nth(n i32) option T =>
    if n < lft.count
      lft.nth n
    else if n < lft.count+ft.count
      ft.nth (n-lft.count)
    else
      rght.nth (n-lft.count-ft.count)
  module redef as_finger_tree option (container.Finger_Tree T) => container.deep lft ft rght
  public redef take (n i32) Sequence T =>
    if n <= lft.count
      lft.as_ft.take n
    else if n <= lft.count+ft.count
      lft.as_ft.append (ft.take n-lft.count)
    else
      deep lft ft (rght.take (n-lft.count-ft.count))
  public redef drop (n i32) Sequence T =>
    if n < lft.count
      deep (lft.drop n) ft rght
    else if n < lft.count+ft.count
      ft
        .drop n-lft.count
        .concat rght.as_ft
    else
      rght.as_ft.drop (n-lft.count-ft.count)



# this is called digit in the paper
#
hand(T type, finger Sequence (Sequence T)) : property.countable
  pre
    debug 2 : 1 <= finger.count <= 4
is
  cnt := finger.map x->x.count .sum
  public redef count i32 => cnt


  drop_first
    pre
      debug 2 : finger.count > 1
  =>
    hand (finger.drop 1)


  drop_last
    pre
      debug 2 : finger.count > 1
  =>
    hand (finger.take finger.count-1)


  prepend(seq Sequence T)
    pre
      debug 2 : finger.count < 4
  =>
    hand ([[seq], finger].flat_map id).as_array_backed


  append(seq Sequence T)
    pre
      debug 2 : finger.count < 4
  =>
    hand ([finger, [seq]].flat_map id).as_array_backed


  nth(n i32) option T =>
    for idx := n, idx-f.count
        f in finger
    until f.is_valid_index idx
      f[idx]
    else
      nil


  as_ft =>
    for res := (container.Finger_Tree T).empty, res.append f
        f in finger
    else
      res


  take (n i32) container.hand T
    pre
      debug 2 : 0 < n < count
  =>
    if n <= finger[0].count
      container.hand [finger[0].take n]
    else if n <= finger[0].count+finger[1].count
      container.hand [finger[0], finger[1].take n-(finger[0].count)]
    else if n <= finger[0].count+finger[1].count+finger[2].count
      container.hand [finger[0], finger[1], finger[2].take n-(finger[0].count+finger[1].count)]
    else
      container.hand [finger[0], finger[1], finger[2], finger[3].take n-(finger[0].count+finger[1].count+finger[2].count)]


  drop (n i32) container.hand T
    pre
      debug 2 : 0 < n < count
  =>
    tmp :=
      for res Sequence (Sequence T) := [[]],
            {
              if to_drop <= 0
                res++[f]
              else
                if to_drop >= f.count
                  res
                else
                  res++[f.drop to_drop]
            }
          to_drop := n, to_drop-f.count
          f in finger
      else
        res
    container.hand tmp.as_array

