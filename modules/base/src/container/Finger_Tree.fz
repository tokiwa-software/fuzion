# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature Finger_Tree
#
# -----------------------------------------------------------------------


#
# The paper introducing the datastructure: https://www.cs.ox.ac.uk/ralf.hinze/publications/FingerTrees.pdf
# The implementation that was used as inspiration for this port: https://github.com/ledbutter/CSharpFingerTree
#
# NYI: UNDER DEVELOPMENT: split0, slice, reverse
#
private:public Finger_Tree(T type) ref : container.abstract_array T is

  public prepend(seq Sequence T) container.Finger_Tree T => abstract
  public append (seq Sequence T) container.Finger_Tree T => abstract

  left  option (Sequence T, container.Finger_Tree T) => abstract
  right option (container.Finger_Tree T, Sequence T) => abstract
  merge(ft container.Finger_Tree T) container.Finger_Tree T => abstract
  app2(seq Sequence (Sequence T), ft container.Finger_Tree T) container.Finger_Tree T => abstract

  public type.empty container.Finger_Tree T => container.empty T

  as_deep deep T => panic "bug!"

  public redef concat (s Sequence T) Sequence T =>
    append s.as_array_backed


  nth0(n i32) option T => abstract


  # get the contents of this array at the given index
  #
  public redef index [ ] (i idx) T
  =>
    nth0 i.as_i32 .val




# an empty finger tree
#
empty(T type) : container.Finger_Tree T is
  public redef length i32 => 0
  public redef prepend(seq Sequence T) container.Finger_Tree T => single T seq
  public redef append (seq Sequence T) container.Finger_Tree T => single T seq
  redef left  option (Sequence T, container.Finger_Tree T) => nil
  redef right option (container.Finger_Tree T, Sequence T) => nil
  redef merge(ft container.Finger_Tree T) container.Finger_Tree T => ft
  redef app2(seq Sequence (Sequence T), ft container.Finger_Tree T) container.Finger_Tree T =>
    for r := ft, r.prepend i
        i in seq.reverse
    else
      r
  redef nth0(n i32) option T => nil
  module redef as_finger_tree option (container.Finger_Tree T) => container.empty T


# a finger tree with only one item
#
single(T type, data Sequence T) : container.Finger_Tree T is
  public redef length i32 => data.count
  public redef prepend(seq Sequence T) container.Finger_Tree T =>
    deep (container.hand [seq]) (empty T) (container.hand [data])
  public redef append (seq Sequence T) container.Finger_Tree T =>
    deep (container.hand [data]) (empty T) (container.hand [seq])
  redef left  option (Sequence T, container.Finger_Tree T) =>
    (data, (container.Finger_Tree T).empty)
  redef right option (container.Finger_Tree T, Sequence T) =>
    ((container.Finger_Tree T).empty, data)
  redef merge(ft container.Finger_Tree T) container.Finger_Tree T =>
    ft.prepend data
  redef app2(seq Sequence (Sequence T), ft container.Finger_Tree T) container.Finger_Tree T =>
    for r := ft, r.prepend i
        i in seq.reverse
    else
      r.prepend data
  redef nth0(n i32) option T => data.nth n
  module redef as_finger_tree option (container.Finger_Tree T) => container.single data



# a deep finger tree, the non trivial case of a finger tree
#
# consist of two hands, left and right, and another Finger_Tree in the middle
#
deep(T type, lft container.hand T, ft container.Finger_Tree T, rght container.hand T) : container.Finger_Tree T is

  # cached count of this deep finger tree
  #
  cnt := lft.count + ft.count + rght.count


  public redef length i32 => cnt


  public redef prepend(seq Sequence T) container.Finger_Tree T =>
    if lft.finger.count = 4
      deep (container.hand [seq, lft.finger[0]]) (ft.prepend ((lft.finger.drop 1).flat_map id).as_array_backed) rght
      # NYI: PERFORMANCE: deep (container.hand [seq, lft.finger[0]]) (ft.prepend lft.finger[3] .prepend lft.finger[2] .prepend lft.finger[0]) rght
    else
      deep (lft.prepend seq) ft rght


  public redef append (seq Sequence T) container.Finger_Tree T =>
    if rght.finger.count = 4
      deep lft (ft.append ((rght.finger.take 3).flat_map id).as_array_backed) (container.hand [rght.finger[3], seq])
      # NYI: PERFORMANCE: deep lft (ft.append rght.finger[0] .append rght.finger[1] .append rght.finger[2]) (container.hand [rght.finger[3], seq])
    else
      deep lft ft (rght.append seq)


  redef left  option (Sequence T, container.Finger_Tree T) =>
    if lft.finger.count = 1
      match ft.left
        nil => (lft.finger[0], from_sequence rght.finger)
        l (Sequence T, container.Finger_Tree T) =>
          x,y := l
          (lft.finger[0], id (container.Finger_Tree T) (deep (container.hand [x]) y rght))
    else
      (lft.finger[0], id (container.Finger_Tree T) (deep lft.drop_first ft rght))


  redef right option (container.Finger_Tree T, Sequence T) =>
    if rght.finger.count = 1
      match ft.right
        nil => (from_sequence rght.finger, rght.finger[count-1])
        r (container.Finger_Tree T, Sequence T) =>
          x,y := r
          (id (container.Finger_Tree T) (deep lft x (container.hand [y])), rght.finger[count-1])
    else
      (id (container.Finger_Tree T) (deep lft ft rght.drop_last), rght.finger[count-1])


  redef merge(ft0 container.Finger_Tree T) container.Finger_Tree T =>
    app2 [] ft0


  redef app2(seq Sequence (Sequence T), ft0 container.Finger_Tree T) container.Finger_Tree T =>
    if ft0.count = 0
      for r container.Finger_Tree T := deep.this, r.append i
          i in seq
      else
        r
    else if ft0.left.val.1.count = 0
      for r container.Finger_Tree T := deep.this, r.append i
          i in seq
      else
        r.append ft0.left.val.0
    else
      d := as_deep
      deep lft (deep.this.app2 ([rght.finger, seq, d.lft.finger].flat_map id).as_array_backed d.ft) d.rght


  from_sequence(seq Sequence (Sequence T)) =>
    for r := container.Finger_Tree T .empty, r.append i
        i in seq
    else
      r


  redef as_deep deep T =>
    deep lft ft rght


  redef nth0(n i32) option T =>
    if n < lft.count
      lft.nth n
    else if n < lft.count+ft.count
      ft.nth (n-lft.count)
    else
      rght.nth (n-lft.count-ft.count)


  module redef as_finger_tree option (container.Finger_Tree T) =>
    container.deep lft ft rght



# this is called digit in the paper
#
hand(T type, finger Sequence (Sequence T)) : property.countable
  pre
    debug 2 : 1 <= finger.count <= 4
    debug 2 : finger.is_array_backed
is
  f0cnt := finger[0].count
  f1cnt := if finger.count < 2 then 0 else finger[1].count
  f2cnt := if finger.count < 3 then 0 else finger[2].count
  f3cnt := if finger.count < 4 then 0 else finger[3].count
  cnt   := f0cnt + f1cnt + f2cnt + f3cnt
  public redef count i32 => cnt


  drop_first
    pre
      debug 2 : finger.count > 1
  =>
    hand (finger.drop 1)


  drop_last
    pre
      debug 2 : finger.count > 1
  =>
    hand (finger.take finger.count-1)


  prepend(seq Sequence T)
    pre
      debug 2 : finger.count < 4
  =>
    # NYI: BUG: triggers ugly case in DFA: hand ([[seq], finger].flat_map id).as_array_backed
    if finger.count = 1
      hand [seq, finger[0]]
    else if finger.count = 2
      hand [seq, finger[0], finger[1]]
    else
      hand [seq, finger[0], finger[1], finger[2]]




  append(seq Sequence T)
    pre
      debug 2 : finger.count < 4
  =>
    # NYI: BUG: triggers ugly case in DFA: hand ([finger, [seq]].flat_map id).as_array_backed
    if finger.count = 1
      hand [finger[0], seq]
    else if finger.count = 2
      hand [finger[0], finger[1], seq]
    else
      hand [finger[0], finger[1], finger[2], seq]


  nth(n i32) option T =>
    if n >= cnt
      nil
    else if n < f0cnt
      finger[0][n]
    else if n < f0cnt+f1cnt
      finger[1][n-f0cnt]
    else if n < f0cnt+f1cnt+f2cnt
      finger[2][n-f0cnt-f1cnt]
    else
      finger[3][n-f0cnt-f1cnt-f2cnt]

