
# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature expanding_array2
#
# -----------------------------------------------------------------------


Internal_Array (
   T type,
   # the array containing the actual data
   data fuzion.sys.internal_array T
) ref is

  used := concur.atomic i32 .new 0


# expanding_array2 -- an array with a length and a (possible larger) capacity
#
# An expanding array is a persistent data structure that has cumulative O(1)
# performance of adding single elements at its end.
#
# WARNING: Due to the high worst-case time for addition, this structure should
# not be used in situations when adding a single element repeatedly to the same
# instance of `expanding_array2`.  If the resulting
# `expanding_array2`'s length is `l`, this will trigger the worst-case
# addition time, resulting in cumulative time O(m*l) for adding an element m
# times.
#
# This constructor is for internal use only, to create instance of
# `expanding_array2`, use `(expanding_array2 T).type.empty` to create an empty
# expanding array instance.
#
private:public expanding_array2
  (
   # element type
   public T type,

   store container.Internal_Array T,

   # the length of the array
   public redef length i32
  )
  : abstract_array T

is


  # Get the capacity of this `expanding_array2`, i.e., the number of
  # elements that can be added without re-allocating the array data.
  #
  public capacity i32 => store.data.length


  # get the contents of this array at the given index
  #
  public redef index [](i idx) T
  =>
    store.data[i]


  # make sure this `expanding_array2` has capacity of at least
  # `new_capacity` and we are able to add elements without
  # allocating a new internal array.
  #
  # This will create an `expanding_array2` whose internal array
  # is the same of `expanding_array2.this` unless the existing
  # capacity is less than `new_capacity` or the existing array
  # was already expanded using by a call to `add`.
  #
  # In the latter cases, a new internal array of required capacity
  # will be allocated and the existing elements will be copied over.
  #
  public fixed ensure_capacity(new_capacity i32) expanding_array2 T
    post
      debug: ((capacity < new_capacity) : result.capacity = new_capacity)
  =>
    expanding_array2 (realloc new_capacity) length


  # return the internal array if the capacity is at least `new_capacity`
  # and, if available, the slot at position `length` is still unused.
  # Otherwise, allocate a new internal array of length `new_capacity` and
  # copy `data`'s elements into the new internal array and filling the
  # remainder with `nil`.
  #
  # Complexity: O(1) if no allocation is required, O(new_capacity)
  # otherwise.
  #
  realloc(new_capacity i32)
  =>
    if capacity >= new_capacity && length = store.used.read
      store
    else
      internal := fuzion.sys.internal_array_init T new_capacity
      for x in 0..length-1 do
        internal[x] := store.data[x]
      res := container.Internal_Array internal
      res.used.write length
      res


  # create a new `expanding_array2` with element i set to v. Grow the array
  # in case i == length.
  #
  # expand is not thread-safe.
  #
  # Complexity: O(1) if no allocation is required, O(length+1) otherwise.
  #
  # Cumulative complexity of adding an element to an empty `expanding_array2`
  # and repeatedly growing the result `add` by a total of `n` elements is
  # `O(n)`.
  #
  # `add` called repeatedly on the same `expanding_array2` creates copies
  # of the underlying array data and hence has performance in `O(length)`.
  #
  public add(v T) expanding_array2 T
    pre
      # prevent i32-overflow in capacity
      safety: (length+1).highest_one_bit < i32.max.highest_one_bit
  =>
    s := realloc (capacity>length ? capacity : (length+1).highest_one_bit*2)
    # NYI: thread safety
    s.used.write length+1
    s.data[length] := v
    expanding_array2 s length+1


  # create a Sequence that consists of all the elements of this Sequence followed
  # by all the elements of s
  #
  public fixed redef concat (s Sequence T) Sequence T =>

    if s.is_empty

      # nothing to be added
      #
      expanding_array2.this

    else if s.finite.is_no_or_unknown

      # use lazy version in case `s` might be infinite, since then code below would not
      # terminate, if `s` is larger than `this`, which would avoid quadratic performance
      # in code like the following:
      #
      #  for i in 0..n
      #      r := (expanding_array2 i32).empty, [i].concat r
      #
      as_list.concat_list s.as_list

    else

      n := s.count
      new_length := length+n
      st := realloc (capacity >= new_length ? capacity : new_length.highest_one_bit*2)

      st.used.write new_length
      _ := s.reduce length (r,t)->
        st.data[r] := t
        r+1


      expanding_array2 st new_length


  # collect the contents of this expanding_array2 as an array.
  #
  public redef as_array array T =>
    array (fuzion.sys.internal_array store.data.data length) unit unit unit


  # create an empty `expanding_array2` of the type this is applied to, e.g.
  #
  #     floats := (container.expanding_array2 f64).empty
  #
  # Complexity: O(1)
  #
  public type.empty container.expanding_array2 T
  =>
    empty default_capacity


  # create an empty `expanding_array2` of the type this is applied to, e.g.
  #
  #     floats := (container.expanding_array2 f64).empty
  #
  # Complexity: O(1)
  #
  public type.empty(initial_capacity i32) container.expanding_array2 T
    pre
      debug: initial_capacity >= 0
  =>
    internal := fuzion.sys.internal_array_init T initial_capacity
    container.expanding_array2 T (container.Internal_Array T internal) 0


  # default capacity of an expanding array created by `type.empty`
  #
  type.default_capacity => 8

