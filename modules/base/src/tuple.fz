# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature tuple
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

# tuple -- feature used to define tuple types
#
# tuple types provide algebraic product types of all the generic arguments
# provided to tuple.
#
# The values within a tuple 'tuple A B C' can be accessed via the tuple's
# argument field 'values' followed by a selector referring to the generic
# argument's position: 'values.0', 'values.1' and 'values.2', respectively.
#
# Syntactic sugar of the Fuzion language permits an alternative notation
# to create values of tuple types as follows
#
#     t := (a, b, c, ... )
#
# is equivalent to
#
#     t := tuple a b c ...
#
# The actual generic types are inferred from the static types of the values
# 'a', 'b', 'c', ... the tuple is created from.
#
# Similarly, syntactic sugar for the destructuring of tuples can be used
# to access the values as in
#
#     (a, b, c, ...) := t
#
# In destructurings, we can denote values we are not interested in using
# '_' as in
#
#  (_, b) := ("first", "second")
#
# which will set 'b' to '"second"' and drop the first element of the tuple.
#
# As an example, say we want to identify a person by its name and its age,
# so we can define
#
#     a := ("Alice" , 11)
#     b := ("Bob"   , 22)
#     c := ("Claire", 33)
#
# Then, we could extract Bob's age using
#
#     (_, age) := b
#
# or Claire's name using
#
#     (name, _) := c
#
# Destructuring also works for general features, e.g.
#
#     point (x,y i32) is {}
#
#     p := point 3, 4
#     (px, py) := p       # will set px to 3 and py to 4
#
# and the destructured value can then be used to create a tuple
#
#     t := (px, py)       # will create tuple<i32,i32> instance
#
# however, tuples are not assignment compatible with general features even
# if they would destructure into the same types, i.e.,
#
#     u tuple i32 i32 = p  # will cause compile time error
#     q point = (7, 12)      # will cause compile time error
#
# The unit tuple '()' can be used as a short-hand to create the empty tuple
# 'tuple'.  The empty tuple can be destructured like any other tuple
# using
#
#     () := ()
#
# even though this has no effect.
#
# An instance of the single tuple 'tuple A' with sole element 'a' can not
# be created using syntactic sugar '(a)', this will produce the plain
# value of 'a' instead. However, destructuring of a single tuple is possible:
#
#    (a0) := tuple a
#
# which is equivalent to
#
#     a0 := a
#
# NYI: A single tuple 'tuple A' is currently not assignment compatible with
# type 'A', which would make handling of general tuples easier.
#
# tuples and destructuring can be used to swap two elements or create a
# permutation as in
#
#     (a, b) := (b, a)
#     (o, t, a, n) := (n, a, t, o)
#
# A tuple type with no actual generic arguments is isomorphic to 'unit', i.e, it
# is a type that has only one single value: '()'.
#
public tuple(public A type...,
             public values A...
             ) : property.orderable,
                 property.hashable
is


  # equality of two tuple `a` and `b` is defined only if all elements of the tuple
  # are equatable and all elements are equal.
  #
  # This will result in a runtime `panic` in case any element type is not equatable.
  #
  public redef type.equality(a, b tuple.this) bool
  =>
    # NYI: BUG: omitting type parameters results in crash (Unimplemented method 'generics' in ThisType):
    # a.values.typed_zip_and_fold b.values true (tuple_zip_equals tuple.this)

    a.values.typed_zip_and_fold bool (tuple_zip_equals tuple.this) b.values true (tuple_zip_equals tuple.this)


  # A total order between two tuples `a` and `b` is defined by the total order of
  # their first elements. If the first `i` element pairs are equal, the order is defined by
  # the `i+1`th element pair.
  #
  # This will result in a runtime `panic` in case any element type is not orderable.
  #
  public redef type.lteq(a, b tuple.this) bool
  =>
    # NYI: BUG: omitting type parameters results in crash (Unimplemented method 'generics' in ThisType):
    # a.values.typed_zip_and_fold b.values true (tuple_zip_lteq tuple.this)

    a.values.typed_zip_and_fold i32 (tuple_zip_lteq tuple.this) b.values 0 (tuple_zip_lteq tuple.this) <= 0


  # create hash code for this tuple
  #
  # This should satisfy the following condition:
  #
  #   (T.equality a b) : (T.hash_code a = T.hash_code b)
  #
  # This will result in a compile-time `panic` in case any element type is not hashable.
  #
  # The algorithm used here is a variation of (XXXHash)[https://xxhash.com] as used in
  # (Python's tuple)[https://github.com/python/cpython/blob/849a80ec412c36bbca5d400a7db5645b8cf54f1f/Objects/tupleobject.c#L305]:
  #
  #   we start with a constant `hash_prime1`
  #   for each value:
  #     we take its hash code * `hash_prime2` and add it
  #     then we rotate by `hash_rotate`
  #     and multiply by `hash_prime3`
  #
  public redef fixed type.hash_code(a tuple.this) u64 : container.typed_fold xxh_prime_5 a.values
  =>
    public redef apply(T type, h u64, v T) u64
    =>
      if T : property.hashable then
        h2 := h +° T.hash_code v *° xxh_prime_2
        h3 := (h2 << xxh_rotate) | (h2 >> (u64 64 - xxh_rotate))
        h3 *° xxh_prime_1
      else
        compile_time_panic  # tuple is not hashable since one element type is not
    res


  # XXH constants from https://xxhash.com/doc/v0.8.3/group___x_x_h64__impl.html
  #
  private type.xxh_prime_1 => u64 0x9E3779B185EBCA87  # factor after each value's hash code was added and result was rotated
  private type.xxh_prime_2 => u64 0xC2B2AE3D27D4EB4F  # factor for adding hash code of values
  private type.xxh_prime_3 => u64 0x165667B19E3779F9  # not needed here
  private type.xxh_prime_4 => u64 0x85EBCA77C2B2AE63  # not needed here
  private type.xxh_prime_5 => u64 0x27D4EB2F165667C5  # initial hash used for empty tuple
  private type.xxh_rotate => u64 31                   # rotation after adding hash code of values


  # create a String from this instance.
  #
  public redef as_string String =>

    concat : container.typed_applicator String is
      public redef apply(V type, e String, v V) String => e="" ? $v : "$e, $v"

    "({values.typed_foldf "" concat})"


# helper feature for `tuple.type.equality` to compare elements in a tuple of type `TUPLE`
#
private tuple_zip_equals(TUPLE type) : container.typed_zipper bool is

  public redef apply(T type,
                     e bool,
                     v, w T) bool
  =>
    if T : property.equatable then
      e && v = w
    else
      compile_time_panic


# helper feature for `tuple.type.lteq` to compare elements in a tuple of type `TUPLE`
#
private tuple_zip_lteq(TUPLE type) : container.typed_zipper i32 is

  public redef apply(T type,
                     e i32,
                     v, w T) i32
  =>
    if T : property.orderable then
      if      e != 0 then  e
      else if v = w  then  0
      else if v < w  then -1
      else                +1
    else
      compile_time_panic
