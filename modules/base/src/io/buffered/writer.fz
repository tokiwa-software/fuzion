# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature io.buffered.writer
#
# -----------------------------------------------------------------------


# buffered.writer effect allows buffered writing
# by using the given Write_Handler
#
# note: anything in the buffer when effect is uninstalled will be discarded.
#
public writer(wh Write_Handler) : effect
is

  buf_size
    # NYI: UNDER DEVELOPMENT: does not work yet, post condition for field
    # post
    #   debug: buf_size > 0
    #   debug: buf_size % os.page_size.as_i32 = 0
  := io.buffer_size.as_i32


  # circular buffer backing this writer
  #
  buffer := (mutate.circular_buffer u8).new LM buf_size.as_i64 0



  # finally
  # i.e. flush all unwritten bytes
  #
  public redef finally unit =>
    match flush
      e error =>
        fuzion.runtime.fault.cause ("{writer.this.type.name}.finally", e.msg)
      unit =>



  # flush the buffer, that is, write out everything that is still
  # in the buffer
  #
  # note that flush is also called automatically
  # when the effect is deinstated
  #
  public flush outcome unit =>
    if buffer.buffered = 0
      unit
    else
      n := buffer.buffered # we are expecting to write this number of bytes
      wh.write (buffer.flush n)


  # store the amount of written bytes
  # in the last write request
  #
  bw := LM.env.new i32 0

  # get the amount of bytes that were written successfully
  # in the last write request
  #
  public bytes_written i32 => bw.get

  # update bytes_written and replace the effect
  #
  bytes_written(n i32) unit =>
    bw <- n
    replace


  # buffered writing of the given array
  #
  write_array(a array u8) outcome unit =>
    bytes_written 0
    # still fits into buffer
    if buffer.available.as_i32 >= a.count
      buffer.enqueue a
    else
      # flush the buffer first
      flush.bind _->
        full_chunks := a.count / buf_size
        for c in 0..full_chunks
            wr := wh.write (a.slice c*buf_size c*(buf_size+1))
        until wr.is_error
          bytes_written c*buf_size
          wr
        else
          bytes_written full_chunks*buf_size
          rest := a.slice full_chunks*buf_size a.count
          buffer.enqueue rest



  # buffered writing of the given data
  # where data may be bytes or a String
  #
  public write (data choice String (Sequence u8)) outcome unit =>
    replace
    match data
      str String => write_array str.utf8.as_array
      s Sequence u8 => write_array s.as_array
