# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature io.buffered.writer
#
# -----------------------------------------------------------------------


# buffered.writer effect allows buffered writing
# by using the given Write_Handler
#
# note: anything in the buffer when effect is uninstalled will be discarded.
#
public writer(wh Write_Handler) : effect
is

  buf_size
    # NYI: UNDER DEVELOPMENT: does not work yet, post condition for field
    # post
    #   debug: buf_size > 0
    #   debug: buf_size % os.page_size.as_i32 = 0
  := io.buffer_size.as_i32


  # circular buffer backing this writer
  #
  buffer := (mutate.circular_buffer u8).new LM buf_size.as_i64 0



  # finally
  # i.e. flush all unwritten bytes
  #
  public redef finally unit =>
    match flush
      e error =>
        fuzion.runtime.fault.cause ("{writer.this.type.name}.finally", e.msg)
      unit =>



  # flush the buffer, that is, write out everything that is still
  # in the buffer
  #
  # note that flush is also called automatically
  # when the effect is deinstated
  #
  public flush outcome unit =>
    if buffer.buffered = 0
      unit
    else
      n := buffer.buffered # we are expecting to write this number of bytes
      wh.write (buffer.flush n)


  # buffered writing of the given byte
  #
  public write_byte (b u8) outcome unit =>
    (write [b]).error


  # helper type for write result
  #
  private:public write_result(public bytes_written i32, public error outcome unit) is


    # was writing successful?
    #
    public ok bool => error.ok


  # buffered writing of the given array
  #
  public write (data Sequence u8) write_result =>

    a := data.as_array

    # still fits into buffer, no need to write yet
    if buffer.available.as_i32 >= a.count
      write_result 0 (buffer.enqueue a)
    else
      buf_count := buffer.buffered
      # flush first
      flush
        .bind _->
          # then write the rest in chunks
          full_chunks := a.count / buf_size
          for c in 0..full_chunks
              wr := wh.write (a.slice c*buf_size c*(buf_size+1))
          until wr.is_error
            write_result buf_count.as_i32+c*buf_size wr
          else
            rest := a.slice full_chunks*buf_size a.count
            er := buffer.enqueue rest
            check debug: er.ok
            write_result buf_count.as_i32+full_chunks*buf_size unit
        .fold id e->
          # flushing failed
          write_result 0 e

