# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature io.buffered.reader
#
# -----------------------------------------------------------------------


# buffered.reader effect allows buffered reading
# by using the given Read_Handler
#
# note: anything in the buffer when effect is uninstalled will be discarded.
#
public reader(rh Read_Handler, buf_size i32) : effect
pre debug: buf_size > 0
is


  # circular buffer backing this reader
  #
  buffer := (mutate.circular_buffer u8).new LM buf_size.as_i64 0


  # read returns the current buffer or end of file.
  # in case the buffer is empty it fills the buffer
  # before returning it.
  #
  public read switch (array u8) (outcome io.end_of_file) => read buf_size


  # read returns the current buffer or end of file.
  # in case the buffer is empty it fills the buffer
  # with up to n bytes before returning it.
  #
  public read(n i32) switch (array u8) (outcome io.end_of_file)
    post
      debug: (result ? outcome => true | a array => !a.is_empty)
  =>
    if buffer.buffered = 0
      match fill_buffer
        unit =>
          # NYI: remove double buffering implementation outside of the reader,
          # just flush the buffer here.
          # m := min n.as_i64 buffer.buffered
          # buffer.flush m
          m := min n buffer.buffered.as_i32
          (buffer.as_array.slice 0 m).as_array
        o outcome io.end_of_file => o
    else
      # NYI: remove double buffering implementation outside of the reader,
      # just flush the buffer here.
      # m := min n.as_i64 buffer.buffered
      # buffer.flush m
      m := min n buffer.buffered.as_i32
      (buffer.as_array.slice 0 m).as_array



  # fill the currently empty buffer with up to buf_size bytes
  #
  fill_buffer switch unit (outcome io.end_of_file)
    pre
      debug: buffer.buffered = 0
  =>
    match rh.read buffer.available.as_i32
      a array u8 =>
        match buffer.enqueue a
          unit => unit
          e error => e
      io.end_of_file =>
        replace
        io.end_of_file
      e error => e


  # discard n items from buffer
  #
  public discard(n i32) unit
    pre
      debug: n >= 0
  =>
    m := min n.as_i64 buffer.buffered
    _ := buffer.flush m


  # discard complete buffer
  #
  public discard unit
  =>
    discard buf_size
