# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion module wolfssl
#
# -----------------------------------------------------------------------

# NYI: UNDER DEVELOPMENT: these are unsupported by fzextract
#
wolfSSL_write(ssl Native_Ref, data mutate.array u8, sz i32) i32 => native
wolfSSL_read(ssl Native_Ref, data mutate.array u8, sz i32) i32 => native
memcpy(dest Native_Ref, src mutate.array u8, sz i32) Native_Ref => native


# NYI: UNDER DEVELOPMENT: define effect
public wolfssl(T type, LM type : mutate, LM2 type: mutate, code ()->T) T ! LM, LM2 =>

  # NYI: CLEANUP: support local mutates
  _ := mut

  check c.wolfSSL_Init=1
  ctx := c.wolfSSL_CTX_new c.wolfTLSv1_2_client_method
  check !(ffi.is_null ctx)

  c.wolfSSL_CTX_SetIORecv ctx (ssl, buf, sz, ctx)->
    match (io.buffered LM).reader.env.read
      s Sequence =>
        (io.buffered LM).reader.env.discard sz
        x := (min sz s.count)
        _ := memcpy buf (mutate.array u8 .from_Sequence s) x
        x
      outcome => exit 1

  c.wolfSSL_CTX_SetIOSend ctx (ssl, buf, sz, ctx)->
    arr := ffi.from_native_array u8 buf sz
    check ((io.buffered LM).writer.env.write arr).ok
    check (io.buffered LM).writer.env.flush.ok
    sz



  ssl := c.wolfSSL_new ctx
  check !(ffi.is_null ssl)


  wolf_ssl_read_handler : io.Read_Handler is

    public redef read(count i32) choice (Sequence u8) io.end_of_file error =>
      arr := mutate.array u8 .new count.as_i64 0
      res := wolfSSL_read ssl arr count
      if res = -1
        error "error reading from ssl ($res) {c.wolfSSL_get_error ssl res}"
      else if res = 0
        io.end_of_file
      else
        arr.as_array res


  wolf_ssl_writer_handler : io.Write_Handler is

    public redef write(b Sequence u8) outcome unit =>
      res := wolfSSL_write ssl (mutate.array u8 .from_Sequence b) b.count
      if res <= 0
        error "error writing to ssl connection ($res) {c.wolfSSL_get_error ssl res}"


  r := ((io.buffered LM2).reader wolf_ssl_read_handler) ! ()->
    (io.buffered LM2).writer wolf_ssl_writer_handler ! ()->
      code.call


  c.wolfSSL_free ssl
  c.wolfSSL_CTX_free ctx
  _ := c.wolfSSL_Cleanup

  r
