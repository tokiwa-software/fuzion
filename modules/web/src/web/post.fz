# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion feature web.post_r
#
# -----------------------------------------------------------------------


# post url via ipv4 using standard ssl port
#
public post4(url String, data Sequence u8, headers container.Map String String) outcome String =>
  post_r net.family.ipv4 443 url data headers


# post url via ipv6 using standard ssl port
#
public post6(url String, data Sequence u8, headers container.Map String String) outcome String =>
  post_r net.family.ipv6 443 url data headers


# post url via ipv4 using standard http port
#
public post4_plain(url String, data Sequence u8, headers container.Map String String) outcome String =>
  post_r net.family.ipv4 80 url data headers


# post url via ipv6 using standard http port
#
public post6_plain(url String, data Sequence u8, headers container.Map String String) outcome String =>
  post_r net.family.ipv6 80 url data headers


# eagerly post an url via http(s), return response as a String
#
public post_r(family net.family.val, port u16, url String, data Sequence u8, headers container.Map String String) outcome String
  pre
    debug: !url.contains_whitespace
=>

  # this lm is used for the raw netwok connection
  #
  net_lm : mutate is

  # this lm is used for reader/writer of the ssl connection
  #
  ssl_lm : mutate is

  is_https      := url.starts_with "https"
  schema_length := "http{is_https ? "s" : ""}://".byte_length

  # extract host and target from url
  #
  host, target :=
    url
      .find "/" schema_length
      .bind (idx -> url.split_at_byte idx)
      .bind (tpl -> (tpl.0.substring schema_length, tpl.1))
      # NYI: error handling
      .get


  # NYI: CLEANUP:
  read_handler(LM type : mutate, arr array u8) : io.Read_Handler is

    pos := LM.env.new 0

    public redef read(count i32) choice (array u8) io.end_of_file error =>
      p := pos.get
      if p > arr.count
        io.end_of_file
      else
        pos <- p + count
        arr.drop p .take count .as_array


  # read the response
  #
  read_reponse(LM type : mutate) ! LM =>
    http
      .read_response LM
      .bind (.body_as_string)


  # do the get request
  #
  write_request(LM type : mutate) ! LM =>
    rm := http
      .request_message
      .new http.post_r target 1 1 ([("Host", host)].concat headers.items) (read_handler LM data.as_array)

    (io.buffered LM).writer.env
      .write (rm.bytes i32.max)
      .error
      .bind _->
        (io.buffered LM).writer.env.flush


  net_lm ! ()->
    net
      .client family net.protocol.tcp host port
      .bind c->
        c.with _ net_lm ()->
          if is_https
            ssl_lm ! ()->
              wolfssl _ net_lm ssl_lm ((write_request ssl_lm).bind _->(read_reponse ssl_lm))
          else
            (write_request net_lm).bind _->(read_reponse net_lm)
