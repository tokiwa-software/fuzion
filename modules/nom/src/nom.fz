# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion nom module feature nom, a parser combinator framework
#
#  Author: Michael Lill (michael.lill@tokiwa.software)
#
# -----------------------------------------------------------------------

# Port of https://github.com/Geal/nom/ by Geoffroy Couprie

# nom is a parser combinator framework
# for more information go to:
# https://github.com/Geal/nom/
nom is

  # a parser takes an input of type I
  # and produces either an error
  # or a result of type O and a rest of type R
  parser(I, R, O type) ref is
    parse(i I) parse_result R O is abstract

    # map the result of parser
    map(OM type, mapper O -> outcome OM) parser I R OM is
      # NYI outer should not be necesarry..
      outer := parser.this
      ref : parser I R OM
        parse(input I) parse_result R OM is
          match outer.parse input
            s success R O =>
              match mapper s.out
                o OM => success s.rest o
                e2 error => e2
            e1 error => e1

  # the result of parsing, if successful
  success(R, O type, rest R, out O) is
    redef asString => $out


  # the result of parser.parse
  parse_result(I, O type) : choice (success I O) error is
    redef asString =>
      match parse_result.this
        s success => $s
        e error => $e



  # choice combinators
  branch is

    # return result of first succeeding parser
    alt(redef I, R, O type, parsers array (parser I R O)) : parser I R O is
      parse(input I) parse_result R O is
        parsers
          .mapSequence (p -> p.parse input)
          .filter (r -> match r
                          success => true
                          error => false)
          .first (error "alt: no parser successful")



  # string parsers
  string_parsers is

    # matches the of str
    tag(str string) : parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint)
    is
      parse(input (Sequence codepoint)) parse_result (Sequence codepoint) (Sequence codepoint) is
        if (input.zip str.asCodepoints (a,b -> (a,b))) ∀ (x -> (a,b) := x; a=b)
          success (input.drop str.codepointLength).as_seq str.asCodepoints
        else
          error "tag ($str) not found"

    # matches input as often as possible but at least m times and at most n times.
    take_while_m_n(m, n i32, cond (codepoint) -> bool) : parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) is
      parse(input (Sequence codepoint)) parse_result (Sequence codepoint) (Sequence codepoint)
      is
        if input.isEmpty
          error "input is empty"
        else
          taken := input
            .take n
            .takeWhile (x -> cond x)
          if taken.count < m
            error "not enough codepoints matched, expected $m or more, got {taken.count}"
          else
            success (input.drop taken.count).as_seq taken.as_seq

    # match zero or more whitespace
    whitespace0 : parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) is
      parse(input (Sequence codepoint)) parse_result (Sequence codepoint) (Sequence codepoint) is
        ws := input.takeWhile (x -> x.isBlank)
        success (input.drop ws.count).as_seq ws.as_seq

    # match one or more digit
    digit1 parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) is
      take_while1 (c -> codepoints.ascii_digit.contains c.val)

    # take while cond is satisfied, but at least one codepoint
    take_while1(cond codepoint -> bool) : parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint), strings is
      # NYI: type necessary currently, crash in both backends
      p parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) := sequence.take_while0 cond
      parse(input (Sequence codepoint)) parse_result (Sequence codepoint) (Sequence codepoint) is
        match p.parse input
          s success =>
            if s.out.isEmpty then error "take_while1, no matches" else success s.rest s.out
          e error => e

    # convert a parser taking a sequence of codepoints to a parser that takes a string
    to_string_input(R, O type, p parser (Sequence codepoint) R O) parser string R O is
      combinator.map_inp (Sequence codepoint) string R O p (str -> str.asCodepoints)

    # convert a parser returning a sequence of codepoints to a parser that returns a string
    to_string_output(I, R type, p parser I R (Sequence codepoint)) parser I R string is
      p.map string (seq -> strings.fromCodepoints seq)

    # convert a parser taking and returning to codepoints to a parser taking and returning a string
    to_string_parser(R type, p parser (Sequence codepoint) R (Sequence codepoint)) parser string R string is
      to_string_output (to_string_input p)



  # parser working on sequences of input
  sequence is

    # take while cond is satisfied
    take_while0(T type, cond T -> bool) : parser (Sequence T) (Sequence T) (Sequence T) is
      parse(input Sequence T) parse_result (Sequence T) (Sequence T) is
        rest Sequence T := input.dropWhile cond
        matched Sequence T := input.takeWhile cond
        success rest matched

    # return result of p1 and p2 as tuple, drop result of p_seq
    separated_pair(redef I type, R1, R2, R3, O1, O2, O3 type, p1 parser I R1 O1, p_sep parser R1 R2 O2, p2 parser R2 R3 O3) : parser I R3 (tuple O1 O3) is
      parse(input I) parse_result R3 (tuple O1 O3) is
        match p1.parse input
          s1 success =>
            match p_sep.parse s1.rest
              s2 success =>
                match p2.parse s2.rest
                  s3 success => success s3.rest (s1.out, s3.out)
                  e3 error => e3
              e2 error => e2
          e1 error => e1



  # parsers applied multiple times
  multi is

    # apply parser multiple times, return results as sequence
    many0 (redef I, O type, p parser I I O) : parser I I (Sequence O) is
      parse(input I) parse_result I (Sequence O) is
        match p.parse input
          s1 success I O =>
            match (parse s1.rest)
              s2 success I (Sequence O) => success s2.rest ([s1.out]++s2.out).as_seq
              error => panic "invalid state, many0 must always succeed."
          # NYI type inference should infer correct type of empty array
          error => success input (lists.empty O).as_seq

    # apply parser at least once, return results as sequence
    many1 (redef I, O type, p parser I I O) : parser I I (Sequence O) is
      parse(input I) parse_result I (Sequence O) is
        match p.parse input
          s1 success I O => (many0 p).parse input
          e error => e

    # parse a separated list of values, zero or more values
    separated_list0(redef I, O type, D type, p_sep parser I I D, p_value parser I I O) : parser I I (Sequence O) is
      parse(input I) parse_result I (Sequence O) is
        match p_value.parse input
          s1 success =>
            match (many0 (combinator.preceded p_sep p_value)).parse s1.rest
              s2 success => success s2.rest ([s1.out]++s2.out).as_seq
              e error => panic "invalid state, many always succeeds"
          # NYI type inference should infer correct type of empty array
          error => success input (lists.empty O).as_seq

    # parse a separated list of values, one or more values
    separated_list1(redef I, O type, D type, p_sep parser I I D, p_value parser I I O) : parser I I (Sequence O) is
      parse(input I) parse_result I (Sequence O) is
        match p_value.parse input
          s1 success =>
            match (many0 (combinator.preceded p_sep p_value)).parse s1.rest
              s2 success => success s2.rest ([s1.out]++s2.out).as_seq
              error => panic "invalid state, many always succeeds"
          e error => e



  # general purpose combinators
  combinator is

    # apply p1 then p2 and return their results as a tuple.
    tuple2(redef I type, O1, O2 type, p1 parser I I O1, p2 parser I I O2) : parser I I (tuple O1 O2) is
      parse(input I) parse_result I (tuple O1 O2) is
        match p1.parse(input)
          s1 success I O1 =>
            match p2.parse s1.rest
              s2 success I O2 =>
                success s2.rest (s1.out, s2.out)
              e2 error => e2
          e1 error => e1

    # apply p1 then p2 then p3 and return their results as a tuple.
    tuple3(redef I type, O1, O2, O3 type, p1 parser I I O1, p2 parser I I O2, p3 parser I I O3) : parser I I (tuple O1 O2 O3) is
      parse(input I) parse_result I (tuple O1 O2 O3) is
        match p1.parse(input)
          s1 success I O1 =>
            match p2.parse s1.rest
              s2 success I O2 =>
                match p3.parse s2.rest
                  s3 success I O3 => success s3.rest (s1.out, s2.out, s3.out)
                  e3 error => e3
              e2 error => e2
          e1 error => e1

    # discard the output of the first parser, return the result of the second parser
    preceded(redef I type, O1, O2 type, p1 parser I I O1, p2 parser I I O2) : parser I I O2 is
      parse(input I) parse_result I O2 is
        match p1.parse input
          s1 success I O1 =>
            p2.parse s1.rest
          e1 error => e1

    # discard p1 and p3, return result of p2
    delimited(redef I type, O1, O2, O3 type, p1 parser I I O1, p2 parser I I O2, p3 parser I I O3) : parser I I O2 is
      parse(input I) parse_result I O2 is
        match p1.parse(input)
          s1 success I O1 =>
            match p2.parse s1.rest
              s2 success I O2 =>
                match p3.parse s2.rest
                  s3 success I O3 => success s3.rest s2.out
                  e3 error => e3
              e2 error => e2
          e1 error => e1

    # map input to parser p
    map_inp(I1, I2 type, redef R, O type, p parser I1 R O, mapper1 I2 -> I1) : parser I2 R O is
      parse(input I2) parse_result R O is
        p.parse (mapper1 input)

    # convert parser to lazy
    as_lazy(redef I, R, O type, p () -> parser I R O) : parser I R O is
      op option (parser I R O) := nil
      p_cached:= mut op
      parse(input I) parse_result R O is
        match p_cached.get
          p parser I R O => p.parse input
          nil =>
            p_cached.put (p())
            parse input



  parsers : combinator, string_parsers, sequence, branch, multi is

    json_value : choice string i64 f64 bool nil (Sequence json_value) (map string json_value) is
      redef asString string is
        match json_value.this
          s string => "\"$s\""
          i i64 => $i
          f f64 => $f
          b bool => $b
          n nil => "null"
          seq Sequence => $seq
          m map => $m

    json =>

      parser_string0 =>

        is_hex_digit(c codepoint) bool is
          codepoints.ascii_digit.contains c.val
            || (u32 0x41 .. 0x46).contains c.val

        parser_hex_unicode =>
          a := preceded (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) (tag "\\") (take_while_m_n 4 4 ((c) -> is_hex_digit c))
          a.map (Sequence codepoint) (d ->
            (c,_) := d.reduce (u32 0, u32 4) (r, c -> (val, exp) := r; (c.parse_u32_hex.val * 10**exp, exp-1))
            [(codepoint c)])

        parse_and_map(t, r string) parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) is
          (tag t).map (Sequence codepoint) (_ -> r.asCodepoints)

        parser_escapings :=
          alt [
            (parse_and_map "\\\"" "\""),
            (parse_and_map "\\\\" "\\"),
            (parse_and_map "\\/" "/"),
            (parse_and_map "\\b" "\b"),
            (parse_and_map "\\f" "\f"),
            (parse_and_map "\\n" "\n"),
            (parse_and_map "\\r" "\r"),
            (parse_and_map "\\t" "\t"),
            parser_hex_unicode
            ]

        parser_regular_codepoint parser (Sequence codepoint) (Sequence codepoint) (Sequence codepoint) :=
          (take_while0 codepoint (c-> (c ≠ "\"") & (c ≠ "\\")))


        p parser (Sequence codepoint) (Sequence codepoint) (Sequence (Sequence codepoint)) := many0 (alt [parser_regular_codepoint, parser_escapings])
        p2 := delimited (tag "\"") p (tag "\"")

        p2.map string (x -> strings.fromCodepoints (x.flatMapSequence codepoint (y -> y)))


      # parser for a json string
      parser_string := parser_string0


      # parser for a json number
      # NYI fraction, negative numbers, exponents
      parser_number =>

        parser_digit_1_9 := take_while0 codepoint (c -> (u32 0x31 .. 0x39).contains c.val)
        parser_digit := take_while0 codepoint (c -> codepoints.ascii_digit.contains c.val)

        parser_fraction :=
          (preceded (tag ".") (many1 parser_digit)).map u64 (x -> (strings.fromCodepoints (x.flatMapSequence codepoint (y -> y))).parse_u64.val)

        # parser_exponent := preceded (alt [tag "e", tag "E"]) parser_signed_digit

        (take_while1 (c -> codepoints.ascii_digit.contains c.val)).map json_value (x -> (strings.fromCodepoints x).parse_i64.val)

      # parser for true
      parser_true :=
        (tag "true").map json_value (x -> true)

      # parser for false
      parser_false :=
        (tag "false").map json_value (x -> false)

      # parser for null
      parser_null :=
        (tag "null").map json_value (x -> nil)

      # parser for json array
      parser_array =>
        parser_no_values parser (Sequence codepoint) (Sequence codepoint) (Sequence json_value) :=
          whitespace0.map (Sequence json_value) (x -> lists.empty json_value)

        parser_comma_sep_value parser (Sequence codepoint) (Sequence codepoint) (Sequence json_value) :=
          separated_list1 (tag ",") parser_json_value_delimited_lazy

        tmp parser (Sequence codepoint) (Sequence codepoint) (Sequence json_value) :=  delimited (tag "[") (alt [parser_comma_sep_value, parser_no_values]) (tag "]")
        tmp.map json_value (x->x)

      # parser for json object
      parser_object =>
        parser_key_value parser (Sequence codepoint) (Sequence codepoint) (tuple string json_value) :=
          separated_pair (delimited whitespace0 parser_string whitespace0) (tag ":") parser_json_value_delimited_lazy

        parser_no_key_values parser (Sequence codepoint) (Sequence codepoint) (Sequence (tuple string json_value)) :=
          whitespace0.map (Sequence (tuple string json_value)) (x -> lists.empty (tuple string json_value))

        parser_key_values parser (Sequence codepoint) (Sequence codepoint) (Sequence (tuple string json_value)) :=
          separated_list1 (tag ",") parser_key_value

        parser_object_seq_tuple parser (Sequence codepoint) (Sequence codepoint) (Sequence (tuple string json_value)) :=
          delimited (tag "\{") (alt [parser_key_values, parser_no_key_values]) (tag "}")

        parser_object_seq_tuple.map json_value (x -> mapOf x.asArray)

      # parser for a json_value: true, false, [], {}, numbers, strings etc.
      parser_json_value =>
        alt (Sequence codepoint) (Sequence codepoint) json_value [
          parser_string.map json_value (x->x),
          parser_number,
          parser_object,
          parser_array,
          parser_true,
          parser_false,
          parser_null]

      # parser for json_value which may be surrounded by whitespace
      parser_json_value_delimited => delimited (Sequence codepoint) (Sequence codepoint) json_value (Sequence codepoint) whitespace0 parser_json_value whitespace0

      # parser for json_value which may be surrounded by whitespace, lazy flavour
      # NYI if this is field leads to crashes
      parser_json_value_delimited_lazy => as_lazy (Sequence codepoint) (Sequence codepoint) json_value ()->parser_json_value_delimited

      # map parser to take string input
      to_string_input parser_json_value_delimited
