23c23
<  * Source of class AbstractInterpreter
---
>  * Source of class AbstractInterpreter2
40c40,54
< import dev.flang.util.Pair;
---
> 
> 
> /*
>  * AbstractInterpreter2 is a variant of AbstractInterpreter that does not
>  * require code generation, i.e., the `RESULT` type parameter is `void`
>  * and `Pair<VALUE,RESULT>` are replaced by just `VALUE`.
>  *
>  * To modify this file, modify
>  *
>  *   build/generated/src/dev/flang/fuir/analysis/AbstractInterpreter2.java
>  *
>  + and then run
>  *
>  *   make -f $(FZ_SRC)/Makefile update-java-patches
>  */
44c58
<  * AbstractInterpreter provides a skeleton of an abstract interpreter
---
>  * AbstractInterpreter2 provides a skeleton of an abstract interpreter
48c62
<  * This class has two generic type parameters that specify the types of values
---
>  * This class has one generic type parameters that specify the type of values
52,55d65
<  *    for a compiler, this might be the code required to obtain that value.
<  *
<  *  - RESULT represents the result of the abstract interpretation. For a
<  *    compiler, this would, e.g, be the generated code.
59c69
< public class AbstractInterpreter<VALUE, RESULT> extends ANY
---
> public class AbstractInterpreter2<VALUE> extends ANY
70c80
<   public static abstract class ProcessExpression<VALUE, RESULT> extends ANY
---
>   public static abstract class ProcessExpression<VALUE> extends ANY
73,79d82
<     /**
<      * Join a List of RESULT from subsequent expressions into a compound
<      * expression.  For a code generator, this could, e.g., join expressions "a :=
<      * 3;" and "b(x);" into a block "{ a := 3; b(x); }".
<      */
<     public abstract RESULT sequence(List<RESULT> l);
< 
92c95
<     public abstract RESULT expressionHeader(int s);
---
>     public abstract void expressionHeader(int s);
97c100
<     public abstract RESULT comment(String s);
---
>     public abstract void comment(String s);
102c105
<     public abstract RESULT nop();
---
>     public abstract void nop();
116,117d118
<      *
<      * @return code to perform the side effects of v and ignoring the produced value.
119c120
<     public RESULT drop(VALUE v, int type)
---
>     public void drop(VALUE v, int type)
121c122
<       return nop(); // NYI: UNDER DEVELOPMENT: should be implemented by BEs.
---
>       nop(); // NYI: UNDER DEVELOPMENT: should be implemented by BEs.
134,135d134
<      *
<      * @return resulting code of this assignment.
137c136
<     public abstract RESULT assignStatic(int s, int f, VALUE tvalue, VALUE val);
---
>     public abstract void assignStatic(int s, int f, VALUE tvalue, VALUE val);
149c148
<     public abstract RESULT assign(int s, VALUE tvalue, VALUE avalue);
---
>     public abstract void assign(int s, VALUE tvalue, VALUE avalue);
165c164
<     public abstract Pair<VALUE, RESULT> call(int s, VALUE tvalue, List<VALUE> args);
---
>     public abstract VALUE call(int s, VALUE tvalue, List<VALUE> args);
176c175
<     public abstract Pair<VALUE, RESULT> box(int s, VALUE v, int vc, int rc);
---
>     public abstract VALUE box(int s, VALUE v, int vc, int rc);
183c182
<     public abstract Pair<VALUE, RESULT> current(int s);
---
>     public abstract VALUE current(int s);
190c189
<     public abstract Pair<VALUE, RESULT> outer(int s);
---
>     public abstract VALUE outer(int s);
210c209
<     public abstract Pair<VALUE, RESULT> constData(int s, int constCl, byte[] d);
---
>     public abstract VALUE constData(int s, int constCl, byte[] d);
221c220
<     public abstract RESULT match(int s, AbstractInterpreter<VALUE, RESULT> ai, VALUE subv);
---
>     public abstract VALUE match(int s, AbstractInterpreter2<VALUE> ai, VALUE subv);
235c234
<     public abstract Pair<VALUE, RESULT> tag(int s, VALUE value, int newcl, int tagNum);
---
>     public abstract VALUE tag(int s, VALUE value, int newcl, int tagNum);
242c241
<     public RESULT reportErrorInCode(String msg) { return comment(msg); }
---
>     public void reportErrorInCode(String msg) { comment(msg); }
301c300
<   public final ProcessExpression<VALUE, RESULT> _processor;
---
>   public final ProcessExpression<VALUE> _processor;
312c311
<   public AbstractInterpreter(FUIR fuir, ProcessExpression<VALUE, RESULT> processor)
---
>   public AbstractInterpreter2(FUIR fuir, ProcessExpression<VALUE> processor)
435,436d433
<    * @param l list that will receive the result
<    *
439c436
<   void assignOuterAndArgFields(List<RESULT> l, int s)
---
>   void assignOuterAndArgFields(int s)
449d445
<             l.add(cur.v1());
451,452c447
<             l.add(out.v1());
<             l.add(_processor.assignStatic(s, or, cur.v0(), out.v0()));
---
>             _processor.assignStatic(s, or, cur, out);
463d457
<             l.add(cur.v1());
466c460
<             l.add(_processor.assignStatic(s, af, cur.v0(), ai));
---
>             _processor.assignStatic(s, af, cur, ai);
481c475
<   public Pair<VALUE,RESULT> processClazz(int cl)
---
>   public VALUE processClazz(int cl)
483d476
<     var l = new List<RESULT>();
487c480
<         assignOuterAndArgFields(l, s);
---
>         assignOuterAndArgFields(s);
490,492c483,484
<     l.add(p.v1());
<     var res = p.v0();
<     return new Pair<>(res, _processor.sequence(l));
---
>     var res = p;
>     return res;
505c497
<   public Pair<VALUE,RESULT> processCode(int s0)
---
>   public VALUE processCode(int s0)
508d499
<     var l = new List<RESULT>();
512,513c503,504
<         l.add(_processor.expressionHeader(s));
<         l.add(process(s, stack));
---
>         _processor.expressionHeader(s);
>         process(s, stack);
522,523c513,514
<         l.add(_processor.reportErrorInCode("Severe compiler bug! This code should be unreachable:\n" +
<                                            _fuir.siteAsString(last_s)));
---
>         _processor.reportErrorInCode("Severe compiler bug! This code should be unreachable:\n" +
>                                      _fuir.siteAsString(last_s));
525a517
> 
530c522
<     return new Pair<>(v, _processor.sequence(l));
---
>     return v;
540,542d531
<    *
<    * @return the result of the abstract interpretation, e.g., the generated
<    * code.
544c533
<   public RESULT process(int s, Stack<VALUE> stack)
---
>   public void process(int s, Stack<VALUE> stack)
556d544
<     RESULT res;
569c557
<               res = _processor.assign(s, tvalue, avalue);
---
>               _processor.assign(s, tvalue, avalue);
573,574c561,562
<               res = _processor.sequence(new List<>(_processor.drop(tvalue, tc),
<                                                     _processor.drop(avalue, ft)));
---
>               _processor.drop(tvalue, tc);
>               _processor.drop(avalue, ft);
585c573
<               res = _processor.comment("Box is a NOP, clazz is already a ref");
---
>               _processor.comment("Box is a NOP, clazz is already a ref");
591,592c579
<               push(stack, rc, r.v0());
<               res = r.v1();
---
>               push(stack, rc, r);
603c590
<             ? new Pair<>(_processor.unitValue(), _processor.drop(tvalue, tc))
---
>             ? _processor.unitValue()
605c592
<           if (r.v0() == null)  // this may happen even if rt is not void (e.g., in case of tail recursion or error)
---
>           if (r == null)  // this may happen even if rt is not void (e.g., in case of tail recursion or error)
612c599
<               push(stack, rt, r.v0());
---
>               push(stack, rt, r);
614d600
<           res = r.v1();
619c605
<           res = _processor.comment(_fuir.comment(s));
---
>           _processor.comment(_fuir.comment(s));
626,627c612
<           push(stack, cl, r.v0());
<           res = r.v1();
---
>           push(stack, cl, r);
636,641c621
<           if (CHECKS) check
<             // check that constant creation has no side effects.
<             (r.v1() == _processor.nop());
< 
<           push(stack, constCl, r.v0());
<           res = r.v1();
---
>           push(stack, constCl, r);
648,649c628,629
<           res = _processor.match(s, this, subv);
<           if (_fuir.alwaysResultsInVoid(s))
---
>           var r = _processor.match(s, this, subv);
>           if (r == null)
652a633,634
>           if (CHECKS) check
>             (r == null || r == _processor.unitValue());
664,665c646
<           push(stack, newcl, r.v0());
<           res = r.v1();
---
>           push(stack, newcl, r);
679c660
<           res = _processor.drop(v, rt);
---
>           _processor.drop(v, rt);
685d665
<           res = null;
694c674
<         say("process done: "+_fuir.siteAsString(s) + ":\t"+_fuir.codeAtAsString(s)+" stack is "+stack+" RES "+res);
---
>         say("process done: "+_fuir.siteAsString(s) + ":\t"+_fuir.codeAtAsString(s)+" stack is "+stack);
696d675
<     return res;
