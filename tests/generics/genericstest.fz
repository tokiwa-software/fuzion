# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test genericstest
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

genericstest is

  chck(b bool, msg String) is
    s := if b
      "PASSED: "
    else
      set_exit_code 1 ? unit =>
                      | error =>
      "FAILED: "
    say (s + msg)

  List(T type) is
    Node(
      el T,
      n, p OptNode) ref : Any is

    Nil is
    OptNode : choice Node Nil is

    h OptNode := Nil
    add(e T) is
      set h := Node e h Nil

    print is
      // for   -- NYI: must update i in the loop prolog
      i := h
      while (i ? Node => { true } | Nil => false)  // NYI: This screams for recursion
        match i
          n Node =>
              say "print el in loop: {n.el}"
              set i := n.n
          Nil =>

    size i32 =>
      set result := 0
      // for   -- NYI: must update i in the loop prolog
      i := h
      while (i ? Node => { true } | Nil => false)   // NYI: This screams for recursion
        match i
          n Node =>
              set result := result + 1
              set i := n.n
          Nil =>

  li := List i32
  li.add 3
  li.add 4
  li.add 5
  li.add 6
  li.add 7
  li.add 8
  li.add 9
  li.print
  say "size: {li.size}"

  Complex1(real, imag i32) is

  Complex(T type, real, imag T) is
  Complex2(rr, ii i32) : Complex rr ii is

  lc0 := List Complex1
  lc0.add (Complex1 3 4)
  lc0.add (Complex1 4 5)
  lc0.add (Complex1 5 6)
  lc0.add (Complex1 7 8)
  lc0.print
  say "0: size: {lc0.size}"

  // The parser uses some tricks to distinguish multiple ">" in a list of actual
  // generics from an operator consisting of multiple ">". So we check if such an
  // operator works here:
  q(a i32) is
    infix >    (b i32) bool => a      > b
    infix >>   (b i32) bool => a/10   > b
    infix >>>  (b i32) bool => a/100  > b
    infix >>>> (b i32) bool => a/1000 > b

    prefix >    i32 => a+1      // >q is 1 larger than q
    prefix >>   i32 => a+10     // >>q is 10 larger
    prefix >>>  i32 => a+100    // >>q is 100 larger
    prefix >>>> i32 => a+1000   // >>q is 1000 larger

    postfix >    i32 => a-1     // q> is 1 smaller than q
    postfix >>   i32 => a-10    // q>> is 10 smaller
    postfix >>>  i32 => a-100   // q>>> is 100 smaller
    postfix >>>> i32 => a-1000  // q>>>> is 1000 smaller

  a q := q 1
  set a := q     2; yak "a({a.a},10) infix > is {a > 10},{a >> 10},{a >>> 10},{a >>>> 10}"
  set a := q    20; yak "a({a.a},10) infix > is {a > 10},{a >> 10},{a >>> 10},{a >>>> 10}"
  set a := q   200; yak "a({a.a},10) infix > is {a > 10},{a >> 10},{a >>> 10},{a >>>> 10}"
  set a := q  2000; yak "a({a.a},10) infix > is {a > 10},{a >> 10},{a >>> 10},{a >>>> 10}"
  set a := q 20000; yak "a({a.a},10) infix > is {a > 10},{a >> 10},{a >>> 10},{a >>>> 10}"

  set a := q     2; yak "a({a.a}) prefix > is {>a},{>>a},{>>>a},{>>>>a}"
  set a := q    20; yak "a({a.a}) prefix > is {>a},{>>a},{>>>a},{>>>>a}"
  set a := q   200; yak "a({a.a}) prefix > is {>a},{>>a},{>>>a},{>>>>a}"
  set a := q  2000; yak "a({a.a}) prefix > is {>a},{>>a},{>>>a},{>>>>a}"
  set a := q 20000; yak "a({a.a}) prefix > is {>a},{>>a},{>>>a},{>>>>a}"

  set a := q     2; yak "a({a.a}) postfix > is {a>},{a>>},{a>>>},{a>>>>}"
  set a := q    20; yak "a({a.a}) postfix > is {a>},{a>>},{a>>>},{a>>>>}"
  set a := q   200; yak "a({a.a}) postfix > is {a>},{a>>},{a>>>},{a>>>>}"
  set a := q  2000; yak "a({a.a}) postfix > is {a>},{a>>},{a>>>},{a>>>>}"
  set a := q 20000; yak "a({a.a}) postfix > is {a>},{a>>},{a>>>},{a>>>>}"

  lc1 := List Complex2
  lc1.add (Complex2 3 4)
  lc1.add (Complex2 4 5)
  lc1.add (Complex2 5 6)
  lc1.add (Complex2 7 8)
  lc1.print
  say "1: size: {lc1.size}"

  // lets see if we can derive actual generics automatically:
  lc2 := List (Complex i32)
  lc2.add (Complex i32 3 4)
  lc2.add (Complex i32 4 5)
  lc2.add (Complex i32 5 6)
  lc2.add (Complex i32 7 8)
  lc2.print
  yak "2: size: {lc2.size}"

  Complex3(redef real, imag i32) : Complex i32 real imag is
  lc3 := List Complex3;
  lc3.add (Complex3 3 4)
  lc3.add (Complex3 4 5)
  lc3.add (Complex3 5 6)
  lc3.add (Complex3 7 8)
  lc3.print
  yak "3: size: {lc3.size}"

  outerGenerics is
    A(T, U type) is
      B(V, W type, y U) is
        p is
          say "y is{y}"
    x0 A i32 bool := A i32 bool
    x1 (A i32 bool).B String bool := (A i32 bool).B String bool true
    x1.p
    unit

  outerGenerics  // should print "y is true".

  opengenerics12 is

    F(A type...) ref is
      f(a A) unit => abstract

    G ref : F i32 bool i32 is
      redef f(a0 i32, a1 bool, a2 i32) unit =>
       chck (a0 = a2) "f only called with first and last element equal"
       chck a1        "f only called with a1 true"
       unit

    x G := G
    x.f 3 true 3
    y F i32 bool i32 := x
    y.f 5 true 5
    z := G
    z.f 7 true 7
    unit
  opengenerics12

  inherting_type_parameteres =>

    # check that type parameters are not inherited and can be replaced
    # by a type parameter with the same name in the heir:
    #
    p(T type)                is show_tp => $T
    x(T type) : p (array  T) is show_tx => $T
    y(T type) : x (option T) is show_ty => $T
    z(T type) : y (list   T) is show_tz => $T

    a := z u64
    chck (a.show_tp = "Type of '" + "array (option (list u64))" + "'") "(z u64).show_tp should be 'array (option (list u64))'"
    chck (a.show_tx = "Type of '" +        "option (list u64)"  + "'") "(z u64).show_tx should be 'option (list u64)'"
    chck (a.show_ty = "Type of '" +                "list u64"   + "'") "(z u64).show_ty should be 'list u64'"
    chck (a.show_tz = "Type of '" +                     "u64"   + "'") "(z u64).show_ty should be 'u64'"

    b := z String
    chck (b.show_tp = "Type of '" + "array (option (list String))" + "'") "(z String).show_tp should be 'array (option (list String))'"
    chck (b.show_tx = "Type of '" +        "option (list String)"  + "'") "(z String).show_tx should be 'option (list String)'"
    chck (b.show_ty = "Type of '" +                "list String"   + "'") "(z String).show_ty should be 'list String'"
    chck (b.show_tz = "Type of '" +                     "String"   + "'") "(z String).show_ty should be 'String'"

    # base line test with different type parameter names
    #
    p1(TP type)                  is show_tp => $TP
    x1(TX type) : p1 (array  TX) is show_tx => $TX
    y1(TY type) : x1 (option TY) is show_ty => $TY
    z1(TZ type) : y1 (list   TZ) is show_tz => $TZ  # note that TP, TX, TY are not visible here

    a := z1 i8
    chck (a.show_tp = "Type of '" + "array (option (list i8))" + "'") "(z i8).show_tp should be 'array (option (list i8))'"
    chck (a.show_tx = "Type of '" +        "option (list i8)"  + "'") "(z i8).show_tx should be 'option (list i8)'"
    chck (a.show_ty = "Type of '" +                "list i8"   + "'") "(z i8).show_ty should be 'list i8'"
    chck (a.show_tz = "Type of '" +                     "i8"   + "'") "(z i8).show_ty should be 'i8'"

    b := z1 codepoint
    chck (b.show_tp = "Type of '" + "array (option (list codepoint))" + "'") "(z codepoint).show_tp should be 'array (option (list codepoint))'"
    chck (b.show_tx = "Type of '" +        "option (list codepoint)"  + "'") "(z codepoint).show_tx should be 'option (list codepoint)'"
    chck (b.show_ty = "Type of '" +                "list codepoint"   + "'") "(z codepoint).show_ty should be 'list codepoint'"
    chck (b.show_tz = "Type of '" +                     "codepoint"   + "'") "(z codepoint).show_ty should be 'codepoint'"


    # check that type parameter if used in child's arg list is not used, but a free type:
    #
    parent(PARENT_TYPE_PARAMETER type, v PARENT_TYPE_PARAMETER) is

    child : parent u8 23 is
      f(x PARENT_TYPE_PARAMETER) => $x + $v + $x
      g(x BLABLA)                => $x + $v + $x

    chck ((child.f [1,2,3]) = "[1,2,3]23[1,2,3]") "PARENT_TYPE_PARAMETER is not inherited, but a free type!"
    chck ((child.g [4,5,6]) = "[4,5,6]23[4,5,6]") "BLABLA is a free type"
    chck ((child.f 2000000000) = "2000000000232000000000") "PARENT_TYPE_PARAMETER is not inherited, but a free type!"
    chck ((child.g 1230000000) = "1230000000231230000000") "BLABLA is a free type"

  inherting_type_parameteres

  exit
