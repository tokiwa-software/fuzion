# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test atomic
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------


# test concur.atomic
#
test_atomic is

  chck0(T type, x, y T, eq (T,T)->bool) =>
    if eq x y
      say "PASSED $x = $y"
    else
      say "FAILED $x /= $y"

  chck(T type: property.equatable, x, y T) =>
    chck0 x y (a,b)->a=b

  test0(T type, a, b, c, d T, eq (T,T)->bool) =>
    a1 := concur.atomic a
    chck0 a1.read a eq
    a1.write b
    chck0 a1.read b eq
    o := a1.compare_and_swap c d
    chck0 a1.read b eq
    o := a1.compare_and_swap b c
    chck0 a1.read c eq
    o := a1.compare_and_swap b d
    chck0 a1.read c eq
    if a1.racy_accesses_supported
      chck0 a1.racy_read c eq
      a1.racy_write d
      chck0 a1.racy_read d eq

  test(T type : property.equatable, a, b, c, d T) =>
    test0 a b c d (v1,v2)->v1=v2

  p(x, y i64) : property.equatable is
    fixed type.equality(a, b test_atomic.p) => a.x = b.x && a.y = b.y
    redef as_string => "$x,$y"

  test 1 2 3 4
  test 0.1 0.2 0.3 0.4
  test true true false false
  test "A" "B" "C" "D"
  test (p 1 1) (p 2 2) (p 3 3) (p 4 4)

  # test unit-like choice
  unit_like : choice unit is
    ord => match unit_like.this
      unit => 0
    redef as_string => match unit_like.this
      unit => "unit"
  test0 unit_like unit unit unit unit ((a,b)-> a.ord=b.ord)

  # test unit-like choice
  unit_like2 : choice unit void is
    ord => match unit_like2.this
      unit => 0
      void => 1   # cannot happen!
    redef as_string => match unit_like2.this
      unit => "unit"
      void => "*** cannot happen ***"
  test0 unit_like2 unit unit unit unit ((a,b)-> a.ord=b.ord)

  # test bool-like choice
  on, off.
  switch : choice on off is
    ord => match switch.this
      on => 0
      off => 1
    redef as_string => match switch.this
      on => "on"
      off => "off"
    type.equality(a, b switch.this) => a.ord = b.ord
  test0 switch on on off off ((a,b)-> a.ord=b.ord)

  # test int-like choice
  red, yellow, green.
  lights : choice red yellow green is
    ord => match lights.this
      red => 0
      yellow => 1
      green => 2
    redef as_string => match lights.this
      red => "red"
      yellow => "yellow"
      green => "green"
  test0 lights red yellow green red ((a,b)-> a.ord=b.ord)

  # test refs-and-units choice
  Sign ref is
  yield : Sign is
    redef as_string => "yield sign"
  prio : Sign is
    redef as_string => "priority sign"
  lights2 : choice red yellow green String Sign is
    ord => match lights2.this
      red => 0
      yellow => 1
      green => 2
      String => 3
      Sign => 4
    redef as_string => match lights2.this
      red => "red"
      yellow => "yellow"
      green => "green"
      s String => s
      s Sign => $s
  test0 lights2 red "blinking" yield prio ((a,b)-> a.ord=b.ord)

  # test general choice
  lights3 : choice red yellow green String error is
    ord => match lights3.this
      red => 0
      yellow => 1
      green => 2
      String => 3
      error => 4
    redef as_string => match lights3.this
      red => "red"
      yellow => "yellow"
      green => "green"
      s String => s
      e error => $e
  test0 lights3 red "blinking" green (error "out-of-order") ((a,b)-> a.ord=b.ord)

  # test general choice
  test0 (option 23) (option 42) nil (option 4711) (a,b)->
    a?? = b?? && (a!! || a.get = b.get)


  a := concur.atomic i64 0x0000000080000000
  c1 := concur.atomic i64 0
  s1 := concur.atomic i64 -1
  c2 := concur.atomic i64 0
  s2 := concur.atomic i64 -1

  if false  # NYI: The tail recursion is not properly recognized in this case yet,
            #      resulting in stack overflow for the C and interpreter backends:
    concur.thread.spawn (()->
      end := time.nano.read + (time.durations.seconds 5).nanos
      for
        s := i64 0, o=v ? s+1 : s
        c in (i64 0)..
      while time.nano.read < end do
        v := a.read
        n := v + 1
        o := a.compare_and_swap v n
      else
        c1.write c
        s1.write s
      )

    concur.thread.spawn (()->
      end := time.nano.read + (time.durations.seconds 5).nanos
      for
        s := i64 0, o=v ? s+1 : s
        c in (i64 0)..
      while time.nano.read < end do
        v := a.read
        n := v + 0x1_0000_0000
        o := a.compare_and_swap v n
      else
        c2.write c
        s2.write s
      )

  else
    # alternative avoiding loops/tail recursion
    end := time.nano.read + (time.durations.ms 100).nanos
    concur.thread.spawn (()->
      rec(d i32) (i32, i32) =>
        if time.nano.read < end
          if d > 0
            (succ0,count0) := (rec d-1)
            (succ1,count1) := (rec d-1)
            (succ0 + succ1, count0 + count1)
          else
            v := a.read
            n := v + 0x1
            o := a.compare_and_swap v n
            if o = v
              (1,1)
            else
              (0,1)
        else
          (0, 0)
      (s, c) := rec 32
      c1.write c.as_i64
      s1.write s.as_i64
      )
    concur.thread.spawn (()->
      rec(d i32) (i32, i32) =>
        if time.nano.read < end
          if d > 0
            (succ0,count0) := (rec d-1)
            (succ1,count1) := (rec d-1)
            (succ0 + succ1, count0 + count1)
          else
            v := a.read
            n := v + 0x1_0000_0000
            o := a.compare_and_swap v n
            if o = v
              (1,1)
            else
              (0,1)
        else
          (0, 0)
      (s, c) := rec 32
      c2.write c.as_i64
      s2.write s.as_i64
      )

  while s1.read < 0 || s2.read < 0 do
    time.nano.sleep (time.durations.ms 20)

  chck s1.read>=0 true
  chck s1.read=(a.read & 0x7fff_ffff) true
  chck s2.read>=0 true
  chck s2.read=(a.read >> 32 & 0x7fff_ffff) true
  chck (c1.read+c2.read>0 : s1.read+s2.read>0) true

  # use `-debug` argument to show CAS success / failure statistics:
  #
  if ((envir.args.nth 1).get "")="-debug"
    say "thread 1: CAS successful: "+s1.read+" failed "+(c1.read-s1.read)+" total "+c1.read
    say "thread 2: CAS successful: "+s2.read+" failed "+(c2.read-s2.read)+" total "+c2.read
    say "a is "+a.read.hex
