# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test native_value
#
# -----------------------------------------------------------------------

cx_cursor(kind i32 /*cursor_kind*/, xdata i32, data Native_Ref) is
cx_string is
cx_type is

ex =>


  clang_createIndex(excludeDeclarationsFromPCH, displayDiagnostics i32) Native_Ref => native
  clang_disposeIndex(idx Native_Ref) unit => native
  clang_parseTranslationUnit(
    idx Native_Ref,
    source_filename array u8,
    command_line_args array Native_Ref,
    num_command_line_args i32,
    unsaved_files Native_Ref,
    num_unsaved_files u32,
    options u32
  ) Native_Ref => native
  clang_getTranslationUnitCursor(translation_unit Native_Ref) cx_cursor => native
  clang_visitChildren(CX_CURSOR_VISITOR type : Function i32 cx_cursor Native_Ref Native_Ref,
                      cursor cx_cursor,
                      visitor CX_CURSOR_VISITOR,
                      client_data Native_Ref) Native_Ref => native
  clang_getCursorKind(cursor cx_cursor) i32 => native
  clang_getCursorSpelling(cursor cx_cursor) cx_string => native
  clang_getCursorResultType(cursor cx_cursor) cx_type => native
  clang_getTypeSpelling(t cx_cursor) cx_string => native
  clang_disposeString(str cx_cursor) unit => native
  clang_Cursor_getNumArguments(cursor cx_cursor) i32 => native
  clang_Cursor_getArgument(cursor cx_cursor, idx i32) cx_cursor => native
  clang_getCursorType(cursor cx_cursor) cx_type => native
  clang_disposeTranslationUnit(tu Native_Ref) unit => native

  CXChildVisit_Recurse i32 => native
  CXCursor_FunctionDecl i32 => native


  visitor : Function i32 cx_cursor Native_Ref Native_Ref is
    redef call(crsr cx_cursor, parent Native_Ref, client_data Native_Ref) =>
      if clang_getCursorKind crsr = CXCursor_FunctionDecl
        func_name := clang_getCursorSpelling crsr
        return_type := clang_getCursorResultType crsr
        return_type_spelling := clang_getTypeSpelling return_type

        num_args := clang_Cursor_getNumArguments crsr
        for i in 1..num_args do
            arg := clang_Cursor_getArgument crsr i
            arg_name := clang_getCursorSpelling arg
            arg_type := clang_getCursorType arg
            arg_type_spelling := clang_getTypeSpelling arg_type

            clang_disposeString arg_name
            clang_disposeString arg_type_spelling

        clang_disposeString func_name
        clang_disposeString return_type_spelling


      CXChildVisit_Recurse

  idx := clang_createIndex 0 0

  fzE_to_native(arr array u8) Native_Ref => native

  header_file := "assert.h"

  # args := ["-I/usr/include", "-I/usr/local/include"]
  #   .map (arg -> fzE_to_native arg.utf8.as_array)
  #   .as_array

  tu := clang_parseTranslationUnit idx header_file.utf8.as_array /* NYI args*/[] 0 ffi.null 0 0

  check !(ffi.is_null tu)

  cursor := clang_getTranslationUnitCursor tu

  _ := clang_visitChildren cursor visitor ffi.null

  clang_disposeTranslationUnit tu
  clang_disposeIndex idx

ex
