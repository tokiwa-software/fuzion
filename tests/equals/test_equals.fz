# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion example test_equals.fz
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

# test_equals tests the equality relation for some standard types and the
# definition of user-defined equality relations
#
test_equals is

  # compare two strings using string.type.equality directly
  #
  eq1(a, b string) => string.type.equality a b

  # compare two strings using equals without type inference for the type
  # parameter
  #
  eq2(a, b string) => equals string a b

  # compare two strings using equals with type inference for the type
  # parameter
  #
  eq3(a, b string) => equals a b

  # compare two strings using infix ≟ without infix syntax and without
  # type inference for the type parameter
  #
  eq4(a, b string) => infix ≟ string a b

  # compare two strings using infix ≟ without infix syntax and with type
  # inference for the type parameter
  #
  eq5(a, b string) => infix ≟ a b

  # compare two strings using infix ≟ with infix syntax and with type
  # inference for the type parameter
  #
  # NYI: This does not compile yet:
  #
  #  eq6(a, b string) => a ≟ b

  say "comparing A and B {eq1 "A" "B"}"
  say "comparing A and A {eq1 "A" "A"}"
  say "comparing A and B {eq2 "A" "B"}"
  say "comparing A and A {eq2 "A" "A"}"
  say "comparing A and B {eq3 "A" "B"}"
  say "comparing A and A {eq3 "A" "A"}"
  say "comparing A and B {eq4 "A" "B"}"
  say "comparing A and A {eq4 "A" "A"}"
  say "comparing A and B {eq5 "A" "B"}"
  say "comparing A and A {eq5 "A" "A"}"
#  say "comparing A and B {eq6 "A" "B"}"
#  say "comparing A and A {(eq6 "A" "A"}"


  # define a color choice type:
  #
  color : choice of red, blue.

  # Has_color provides an equality relation for instances that provide
  # a 'col' feature
  #
  Has_color ref is

    # the color of this instance
    #
    col color is abstract

    # equality relation comparing the value produced by 'col'
    #
    redef type.equality(a, b test_equals.Has_color) =>

      # NYI: There is currently no easy way to compare choice types, so we do exhaustive
      # matches:
      #
      match a.col
        test_equals.red  => match b.col
                              test_equals.red  => true
                              *                => false
        test_equals.blue => match b.col
                              test_equals.blue => true
                              *                => false

  # compare two instances of Has_color
  #
  eq_color(a, b Has_color) => infix ≟ a b

  # a colored_text is a string with an associated color:
  #
  colored_text(

    # the color
    col color,

    # the string
    utf8 Sequence u8)

   : Has_color, string is

    # equality relation comparing color and strings
    #
    redef type.equality(a, b test_equals.colored_text) =>
      (test_equals.eq_color a b &&
       string.type.equality a b   )

  # create some colored text:
  #
  red_cat  := colored_text red  "cat".utf8
  blue_cat := colored_text blue "cat".utf8
  blue_dog := colored_text blue "dog".utf8

  say "comparing red cat and blue cat as strings: {eq3 red_cat blue_cat}"
  say "comparing red cat and blue dog as strings: {eq3 red_cat blue_dog}"
  say "comparing red cat and blue cat as Has_color: {eq_color red_cat blue_cat}"
  say "comparing blue cat and blue dog as Has_color: {eq_color blue_cat blue_dog}"

  # NYI: does not work yet:
  #
  # say "comparing red cat and blue cat as colored_text: {equals red_cat blue_cat}"
  # say "comparing red cat and red cat as colored_text: {equals red_cat red_cat}"

  # NYI: does not work yet:
  #
  #  say (infix ≟ red_cat blue_cat)
