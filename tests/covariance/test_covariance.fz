# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test test_covariance
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

# a test for defining abstract data type using covariance argument and result types
# in children
#
test_covariance is

  # a simple, numeric type providing special elements zero and one and operations
  # lessThan, plus, minus and to_u32
  #
  num0 is

    # special values
    #
    type.zero num0.this is abstract
    type.one  num0.this is abstract

    # if num0.this less than other?
    #
    lessThan(other num0.this) bool is abstract

    plus (other num0.this) num0.this is abstract
    minus(other num0.this) num0.this is abstract

    to_u32_loop =>
      for
        x := num0.this, x.minus num0.this.type.one
        u := u32 0, u+1
      while num0.this.type.zero.lessThan x
      else
        u

    # convert this to corresponding values as an 'u32'
    #
    to_u32 u32 is
      t := num0.this.type
      if t.zero.lessThan num0.this
        (minus t.one).to_u32 + 1
      else
        0

    # create string representation consisting of type, to_u32
    # and valueString
    #
    redef as_string => "num0.this {to_u32} {to_u32_loop} '$valueString'"

    # string representation of this value, to be implemented by
    # children.
    #
    valueString String is abstract


  # integer mod 2 implementation of num0
  #
  intM2(is_zero bool) : num0 is
    fixed z => intM2 true
    fixed o => intM2 false
    fixed type.zero => test_covariance.intM2 true
    fixed type.one => test_covariance.intM2 false
    fixed lessThan(other intM2) => is_zero && !other.is_zero
    fixed plus(other intM2) => if is_zero then other else intM2 !other.is_zero
    fixed minus(other intM2) => plus other
    redef valueString => if is_zero then "0 mod 2" else "1 mod 2"

  # integer mod 5 implementation of num0
  #
  intM5(v u8) : num0 is
    fixed z => intM5 0
    fixed o => intM5 1
    fixed type.zero => test_covariance.intM5 0
    fixed type.one => test_covariance.intM5 1
    fixed lessThan(other intM5) => v < other.v
    fixed plus(other intM5) => intM5 (v + other.v)%5
    fixed minus(other intM5) => intM5 (v - other.v)%5
    redef valueString => "$v mod 5"

run_test_covariance =>

  test(N type : test_covariance.num0, x, y N) =>
    say x
    say y
    say (x.plus y)
    say (x.plus x)
    say (y.plus y)
    z := y.plus y
    say z
    z := z.plus z
    say z
    z := z.plus z
    say z

  x := test_covariance.intM2 true
  y := test_covariance.intM2 false
  say x
  say y
  say (x.plus y)
  say (x.plus x)
  say (y.plus y)
  z := y.plus y
  say z
  z := z.plus z
  say z
  z := z.plus z
  say z
  test x y


  x := test_covariance.intM5 0
  y := test_covariance.intM5 1
  say x
  say y
  say (x.plus y)
  say (x.plus x)
  say (y.plus y)
  z := y.plus y
  say z
  z := z.plus z
  say z
  z := z.plus z
  say z
  test x y


# This test creates nested features with accesses to the outer features' this.type
# values.  Then, it creates new features by inheriting from the outer features and
# redefining type features.
#
# It will then be tested that the corresponding type features respect the nesting
# and inheritance relation.
#
test_this_type =>

  a is
    type.s => "a"
    redef as_string => "{a.this.type.s}"
    b is
      type.s => "b"
      redef as_string => "{a.this.type.s}{b.this.type.s}"
      c is
        type.s => "c"
        d is
          type.s => "d"
          redef as_string => "{a.this.type.s}{b.this.type.s}{c.this.type.s}{d.this.type.s}"

  k : a is
    redef type.s => "k"

  l : a.b is
    redef type.s => "l"

  p : a is
    redef type.s => "p"
  q : a is
    redef type.s => "q"
    r : b is
      redef type.s => "r"
  s : a is
    redef type.s => "s"
    t : b is
      redef type.s => "t"
      u : c is
        redef type.s => "u"
  v : a is
    redef type.s => "v"
    w : b is
      redef type.s => "w"
      x : c is
        redef type.s => "x"
        y : d is
          redef type.s => "y"

  z : a.b.c.d is
    redef type.s => "z"

  Z : v.w.x.y is
    redef type.s => "Z"

  chck $a       "a"
  chck $k       "k"
  chck $a.b     "ab"
  chck $l       "al"
  chck $a.b.c.d "abcd"
  chck $p.b.c.d "pbcd"
  chck $q.r.c.d "qrcd"
  chck $s.b.c.d "sbcd"
  chck $s.t.c.d "stcd"
  chck $s.t.u.d "stud"
  chck $v.b.c.d "vbcd"
  chck $v.w.c.d "vwcd"
  chck $v.w.x.d "vwxd"
  chck $v.w.x.y "vwxy"
  chck $z       "abcz"
  chck $Z       "vwxZ"

  chck(s1, s2 String) =>
    say (if s1 = s2 then "PASS: $s1 = $s2" else "*** FAIL ***: $s1 /= $s2")

# This test creates nested features with inner type features that use outer features'
# this.type in their signature.
#
test_this_type_in_type_feature =>

  abc is
    def(s String) is
      ghi is
        jkl(val i32, msg String) is
          type.choose1(a, b             jkl.this)             jkl.this is if a.val < b.val then a else b
          type.choose2(a, b         ghi.jkl.this)         ghi.jkl.this is if a.val < b.val then a else b
          type.choose3(a, b     def.ghi.jkl.this)     def.ghi.jkl.this is if a.val < b.val then a else b
          type.choose4(a, b abc.def.ghi.jkl.this) abc.def.ghi.jkl.this is if a.val < b.val then a else b
          type.choose5(a, b     def.ghi.jkl.this) abc.def.ghi.jkl.this is if a.val < b.val then a else b
          type.choose6(a, b         ghi.jkl.this) abc.def.ghi.jkl.this is if a.val < b.val then a else b
          type.choose7(a, b             jkl.this) abc.def.ghi.jkl.this is if a.val < b.val then a else b
          type.choose8(a, b abc.def.ghi.jkl.this)     def.ghi.jkl.this is if a.val < b.val then a else b
          type.choose9(a, b abc.def.ghi.jkl.this)         ghi.jkl.this is if a.val < b.val then a else b
          type.chooseA(a, b abc.def.ghi.jkl.this)             jkl.this is if a.val < b.val then a else b

          type.choose1L(a, b     def.this)     def.this is a
          type.choose1R(a, b     def.this)     def.this is b
          type.choose2L(a, b abc.def.this) abc.def.this is a
          type.choose2R(a, b abc.def.this) abc.def.this is b
          type.choose3L(a, b abc.def.this)     def.this is a
          type.choose3R(a, b abc.def.this)     def.this is b
          type.choose4L(a, b     def.this) abc.def.this is a
          type.choose4R(a, b     def.this) abc.def.this is b

          redef as_string => "abc.def.ghi.jkl $val $msg"

      redef as_string => s

  v1 := (abc.def "ignore").ghi.jkl 1 "PASS"
  v2 := (abc.def "ignore").ghi.jkl 2 "*** FAIL ***"

  say (abc.def.ghi.jkl.type.choose1 v1 v2)
  say (abc.def.ghi.jkl.type.choose2 v1 v2)
  say (abc.def.ghi.jkl.type.choose3 v1 v2)
  say (abc.def.ghi.jkl.type.choose4 v1 v2)
  say (abc.def.ghi.jkl.type.choose5 v1 v2)
  say (abc.def.ghi.jkl.type.choose6 v1 v2)
  say (abc.def.ghi.jkl.type.choose7 v1 v2)
  say (abc.def.ghi.jkl.type.choose8 v1 v2)
  say (abc.def.ghi.jkl.type.choose9 v1 v2)
  say (abc.def.ghi.jkl.type.chooseA v1 v2)

  say (abc.def.ghi.jkl.type.choose1 v2 v1)
  say (abc.def.ghi.jkl.type.choose2 v2 v1)
  say (abc.def.ghi.jkl.type.choose3 v2 v1)
  say (abc.def.ghi.jkl.type.choose4 v2 v1)
  say (abc.def.ghi.jkl.type.choose5 v2 v1)
  say (abc.def.ghi.jkl.type.choose6 v2 v1)
  say (abc.def.ghi.jkl.type.choose7 v2 v1)
  say (abc.def.ghi.jkl.type.choose8 v2 v1)
  say (abc.def.ghi.jkl.type.choose9 v2 v1)
  say (abc.def.ghi.jkl.type.chooseA v2 v1)

  w1 := abc.def "PASS"
  w2 := abc.def "*** FAIL ***"

  say (abc.def.ghi.jkl.type.choose1L w1 w2)
  say (abc.def.ghi.jkl.type.choose1R w2 w1)
  say (abc.def.ghi.jkl.type.choose2L w1 w2)
  say (abc.def.ghi.jkl.type.choose2R w2 w1)
  say (abc.def.ghi.jkl.type.choose3L w1 w2)
  say (abc.def.ghi.jkl.type.choose3R w2 w1)
  say (abc.def.ghi.jkl.type.choose4L w1 w2)
  say (abc.def.ghi.jkl.type.choose4R w2 w1)

run_test_covariance
test_this_type
test_this_type_in_type_feature
