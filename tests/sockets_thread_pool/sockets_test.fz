# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test sockets
#
# -----------------------------------------------------------------------

sockets_test is

  lm : mutate is

  servers :=
    concur.atomic [(u16 0),
                   (u16 0),
                   (u16 0),
                   (u16 0)]

  set_server_port(idx i32, new u16) =>
    _ :=
      for r := servers.read
      while !(servers.compare_and_set r (r.put idx new))


  # server handles one connection at a time
  #
  server(family net.family.val, protocol net.protocol.val) =>

    say_silent(s Any) => unit

    accept =>
      (net.server.env.accept.bind c->
        sc := c.in_thread_pool unit concur.thread_pool lm lm ()->
          chan => net.channel.env

          say_silent "$protocol/$family-server, accepted connection"
          say_silent chan.get_peer_address
          say_silent chan.get_peer_port

          rr := (io.buffered lm).read_line_while (s -> !s.is_empty)

          say_silent "$protocol/$family-server, read lines: >{rr}<"

          match protocol
            net.protocol.tcp =>

              res := "received: {rr.as_string}\n\n"

              w =>
                x := ((io.buffered lm).writer.env.write res.utf8.as_array).error

                match x
                  unit => (io.buffered lm).writer.env.flush
                  error => x

              match w
                e error => say_silent "$protocol/$family-server, write error $e"
                * => say_silent "$protocol/$family-server, write succeeded"


            net.protocol.udp =>
              # rest of udp datagram was discarded
            * =>
              panic "NI"

        tmp := sc.get
        _ := c.close
        tmp.ok).ok


    for port := u16 30000, port+1
        # install server in env
        r := net.server.start family protocol port ()->
               set_server_port (server_ident family protocol) port
               while accept
               do
    until r.ok || port > 30100
      if !r.ok
        panic "last error: $r"



  # client
  #
  client(family net.family.val, protocol net.protocol.val, host String, port u16, num i32) =>

    match net.client family protocol host port
      error =>
        say "$protocol/$family-client {sockets_test.client.this.num}, $host: error establishing connection"
      c net.connection =>

        res := c.in_thread_pool String concur.thread_pool lm lm ()->

            chan => net.channel.env

            req := ("GET / HTTP\n"
              + "Host: $host\n"
              + "Client: {sockets_test.client.this.num}\n\n")

            w =>
              _ := (io.buffered lm).writer.env.write req.utf8.as_array
              _ := (io.buffered lm).writer.env.flush

            str := "$protocol/$family-client {sockets_test.client.this.num}, write to $host => {w}"

            match protocol
              net.protocol.tcp =>

                rr := (io.buffered lm).read_line_while (s -> !s.is_empty)

                str + "\n" + "$protocol/$family-client {sockets_test.client.this.num}, read lines from  $host: >{rr}<"

              # for UDP reading would block indefinitely
              net.protocol.udp =>
                # rest of udp datagram was discarded
                str

              * =>  panic "NI"

        tmp := res.get
        _ := c.close
        say tmp



  # a number for protocol p to be used for
  # choosing a unique port for every protocol/family
  #
  protocol_num(p net.protocol.val) u16 =>
    match p
      net.protocol.tcp => 0
      net.protocol.udp => 1
      nil => 2

  # a number for family f to be used for
  # choosing a unique port for every protocol/family
  #
  family_num(f net.family.val) u16 =>
    match f
      net.family.ipv4 => 0
      net.family.ipv6 => 3


  # get server identifier for given family/protocol
  #
  server_ident(f net.family.val, p net.protocol.val) =>
    match f
      net.family.ipv4 =>
        match p
          net.protocol.tcp => 0
          net.protocol.udp => 1
          nil => panic "unexpected case"
      net.family.ipv6 =>
        match p
          net.protocol.tcp => 2
          net.protocol.udp => 3
          nil => panic "unexpected case"


  port(f net.family.val, p net.protocol.val) =>
    while servers.read[server_ident f p] = 0
      time.nano.sleep (time.duration.s 1)
    servers.read[server_ident f p]

########### Tests ################

  families array net.family.val := [net.family.ipv4, net.family.ipv6]
  protocols array net.protocol.val := [net.protocol.tcp, net.protocol.udp]
  for f in families do
    for p in protocols do
      _ := concur.threads.spawn ()->
        _ := concur.thread_pool 3 ()->
          _ := server f p

  for f in families do
    for p in protocols do
      say "### $p/$f-Tests ###"

      # write request to server and read response
      for i in 1..2 do
        _ := concur.thread_pool 3 ()->
          client f p (net.family.localhost f) (port f p) i

  exit 0
