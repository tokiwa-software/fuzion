# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test looptest_negative
#
#  Author: Fridtjof Siebert (siebert@tokiwa.software)
#
# -----------------------------------------------------------------------

looptest_negative is

  exit_code := mut 0

  chck (msg String, b bool) unit =>
    if b
      say "PASSED: $msg"
    else
      say "FAILED: $msg"
      exit_code <- 1

  a := array i32 100 (i -> if (i % 23 = 0) (-2)*i else i*i)

  say "testLoop_neg1: loop return 3333 on success and 4444 in else branch"
  testLoop_neg1(data array i32, isWhatWeWant i32 -> bool) =>
    for
      ix := 0, ix + 1
    while ix < data.length
      element := data[ix]
    until isWhatWeWant(data[ix])     //  1.a should flag an error: incompatible result types i32 vs. String
      3333              //  1.a should flag an error: incompatible result types i32 vs. String
    else
      "4444"            //  1.b should flag an error: incompatible result types i32 vs. String

  say "testLoop_neg2: loop return success index as default and 4444 in else branch"
  testLoop_neg2(data array i32, isWhatWeWant i32 -> bool) =>
    for
      ix := 0, ix + 1
    while ix < data.length
      element := data[ix]
    until isWhatWeWant(data[ix])    //  2.a should flag an error: incompatible result types i32 vs. String
      ix                //  2.a should flag an error: incompatible result types i32 vs. String
    else
      "4444"            //  2.b should flag an error: incompatible result types i32 vs. String

  say "testLoop_neg3: loop return 3333 on success, index as default"
  testLoop_neg3(data array i32, isWhatWeWant i32 -> bool) =>
    for
      ix := 0, ix + 1
    while ix < data.length
      element := data[ix]
    until isWhatWeWant(data[ix])
      "3333"
  neg3i i32    := testLoop_neg3 a (i -> i > 10) //  3.a should flag an error: incompatible result types VOID vs. i32
  neg3s String := testLoop_neg3 a (i -> i > 10) //  3.b should flag an error: incompatible result types VOID vs. String

  say "testLoop_neg4: loop return 4444 on else branch, no success possible"
  testLoop_neg4(data array i32, isWhatWeWant i32 -> bool) =>
    for
      ix := 0, ix + 1
    while ix < data.length
      element := data[ix]
    else
      "4444"            //  ok

  say "testLoop_neg5: loop returns last index"
  testLoop_neg5(data array i32, isWhatWeWant i32 -> bool) =>
    for
      ix := 0, ix + 1   // ok
    while ix < data.length

  testWriteToIndexVar is
    for
      i i32 := 0, i+1
      j := 100, j-1
      k in 0..10
      l in 0..20 : 2
    do
      set i := 2   //  4. should flag an error: must not assign value to loop index var
      set j := i*i //  5. should flag an error: must not assign value to loop index var
      set k := 3   //  6. should flag an error: must not assign value to loop index var
      set l := k-j //  7. should flag an error: must not assign value to loop index var
  testWriteToIndexVar

  testWriteToDeclaredVar is
    for
      i i32 := 0
      j := 100
    do
      set i := i+2 //  7a. should flag an error: must not assign value to loop index var
      set j := i*i //  7b. should flag an error: must not assign value to loop index var
  testWriteToDeclaredVar

  testNonBooleanWhile1 is
    while "string"  // 8. should flag an error: must be of type bool
  testNonBooleanWhile1

  testNonBooleanWhile2 is
    while 23  // 9. should flag an error: must be of type bool
  testNonBooleanWhile2

  testBooleanWhile3 { while false  { } }; testBooleanWhile3  // ok
  testBooleanWhile4 { while true   { } }; testBooleanWhile4  // ok
  testBooleanWhile7 { while !false { } }; testBooleanWhile7  // ok
  testBooleanWhile8 { while !true  { } }; testBooleanWhile8  // ok

  testNonBooleanUntil1 is
    do
    until "string"  // 10. should flag an error: must be of type bool
  testNonBooleanUntil1

  testNonBooleanUntil2 is
    do
    until 23  // 11. should flag an error: must be of type bool
  testNonBooleanUntil2

  testBooleanUntil3 { do { } until false  }; testBooleanUntil3  // ok
  testBooleanUntil4 { do { } until true   }; testBooleanUntil4  // ok
  testBooleanUntil7 { do { } until !false }; testBooleanUntil7  // ok
  testBooleanUntil8 { do { } until !true  }; testBooleanUntil8  // ok

  exit exit_code.get
