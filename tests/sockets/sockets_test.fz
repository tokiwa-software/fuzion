# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test sockets
#
# -----------------------------------------------------------------------

sockets_test is

  localhost(f net.family.val) String is
    match f
      net.family.ipv4 => "127.0.0.1"
      net.family.ipv6 => "::1"
      net.family.local => panic "NYI"


  # server handles one connection at a time
  start_server_in_background(family net.family.val, protocol net.protocol.val, port u16) =>
    # start server in background
    concur.thread.spawn ()->

      # install server in env
      say "opened $protocol/$family-server on port $port: {(net.server family protocol port)}"

      for ar := net.server.accept, net.server.accept
      while net.server.is_active
      do
        say "$protocol/$family-server, accepted connection: $ar"

        rr := (net.channel net.server)
          .read 11
          .or(error "error")
          .bind String (d -> String.type.from_bytes  d)

        say "$protocol/$family-server, read  11 bytes: >{rr}<"

        match protocol
          net.protocol.tcp =>
            # read more than available
            rr := (net.channel net.server)
              .read 100
              .or (error "error")
              .bind String (d -> String.type.from_bytes  d)

            say "$protocol/$family-server, read 100 bytes: >{rr}<"

            res := ("HTTP 200 OK\n"
              + "content-length: 0")

            wr := (net.channel net.server)
              .write res.utf8
              .or (error "error")
            say "$protocol/$family-server, write {wr}"
          net.protocol.udp =>
            # rest of udp datagram was discarded
          * =>
            panic "NI"


    # wait for server to start
    time.nano.sleep (time.durations.s 1)


    # try start another server on same port in background
    concur.thread.spawn ()->

      # server is installed in env
      say "opened $protocol/$family-server on port $port: {(net.server family protocol port).or(error "error")}"

      unit

    # wait for server to start
    time.nano.sleep (time.durations.s 1)


  client(family net.family.val, protocol net.protocol.val, host String, port u16, num i32) array String is
    match net.client sockets_test family protocol host port
      err error => ["$protocol/$family-client $num, $host:$port: error establishing connection"]
      unit unit =>

        req := ("GET / HTTP\n"
          + "Host: $host\n"
          + "Client: $num\n")

        s1 := "$protocol/$family-client $num, write to $host:$port: {((net.channel sockets_test).write req.utf8).or(error "error")}"

        match protocol
          net.protocol.tcp =>
            # for UDP this read would block indefinitely
            rr := (net.channel sockets_test)
              .read 12
              .or(error "error")
              .bind String (d -> String.type.from_bytes  d)
            s2 := "$protocol/$family-client $num, read  12 bytes from  $host:$port: >{rr}<"

            # read more than available
            rr := (net.channel sockets_test)
              .read 100
              .or(error "error")
              .bind String (d -> String.type.from_bytes  d)
            s3 := "$protocol/$family-client $num, read 100 bytes from  $host:$port: >{rr}<"
            [s1,s2,s3]
          net.protocol.udp =>
            # rest of udp datagram was discarded
            [s1]
          * =>  panic "NI"



########### Tests ################

  families array net.family.val := [net.family.ipv4, net.family.ipv6]
  protocols array net.protocol.val := [net.protocol.tcp, net.protocol.udp]
  for p in protocols do
    for f in families do
      say "### $p/$f-Tests ###"

      # NYI we don't have proper means yet to communicate
      # with other threads. So we can't shut down the server
      # after a test. For now use a different port for every test.
      port := u16 40000 + p.as_num.as_u16*10 + f.as_num.as_u16

      # should result in refused connection
      # since no server is running yet
      say (String.type.join (client f p (localhost f) port 0) "\n")


      start_server_in_background f p port

      # write request to server and read response
      clients_result := (1..2)
        .map (i -> client f p (localhost f) port i)


      # wait for server to receive packages and print everything
      time.nano.sleep (time.durations.s 1)

      say (String.type.join (clients_result.flatMap String (x -> x)) "\n")
