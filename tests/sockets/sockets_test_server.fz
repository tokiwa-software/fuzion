# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test sockets
#
# -----------------------------------------------------------------------

sockets_test_server =>

  # server handles one connection at a time
  start_server(family net.family.val, protocol net.protocol.val, port u16) =>
    # install server in env
    say "opened $protocol/$family-server on port $port: {(net.server family protocol port)}"

    for ar := net.server.accept, net.server.accept
    while net.server.is_active
    do
      say "$protocol/$family-server, accepted connection: $ar"
      say (net.channel net.server).get_peer_address
      say (net.channel net.server).get_peer_port

      rr1 := (net.channel net.server)
        # read less than available bytes
        .read 11
        .or(error "error")
        .bind String (d -> String.type.from_bytes  d)

      say "$protocol/$family-server, read  11 bytes: >{rr1}<"

      match protocol
        net.protocol.tcp =>
          rr2 := (net.channel net.server)
            # read more than available bytes
            .read 100
            .or (error "error")
            .bind String (d -> String.type.from_bytes  d)

          say "$protocol/$family-server, read 100 bytes: >{rr2}<"

          res := "received: {rr1.as_string + rr2.as_string}"

          wr := (net.channel net.server)
            .write res.utf8
            .or (error "error")
          say "$protocol/$family-server, write {wr}"
        net.protocol.udp =>
          # rest of udp datagram was discarded
        * =>
          panic "NI"


  f net.family.val   := if envir.args.drop(1).first = "ipv4" then net.family.ipv4   else net.family.ipv6
  p net.protocol.val := if envir.args.drop(2).first = "tcp"  then net.protocol.tcp  else net.protocol.udp


  # a number for protocol p to be used for
  # choosing a unique port for every protocol/family
  #
  protocol_num(p net.protocol.val) u16 is
    match p
      net.protocol.tcp => 0
      net.protocol.udp => 1
      nil => 2

  # a number for family f to be used for
  # choosing a unique port for every protocol/family
  #
  family_num(f net.family.val) u16 is
    match f
      net.family.ipv4 => 0
      net.family.ipv6 => 3

  # For now use a different port for every test.
  port := u16 40000 + (protocol_num p) + (family_num f)

  # NYI c tests fail
  # no_out : io.Print_Handler is
  #   print(s Any) => unit

  # io.out no_out ()->
  #   start_server f p port
  #   unit

  start_server f p port
