# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test reg_issue5818_calling_with_open_type
#
# -----------------------------------------------------------------------

# Several test cases that call features with type and value arguments of
# open type.
#
# This is the same code as ../reg_issue5818_calling_with_open_type_negative/reg_issue5818_calling_with_open_type.fz,
# only with all failing cases commented out such that we can verify that the
# positive cases work.
#
reg_issue5818_calling_with_open_type =>


  # ------------------------------


  # Start with a simple case of just one open type parameter
  #
  f(A type ...) =>
    say "f $A"

  f                                                                # ok
  f u8                                                             # ok
  f u8 unit i32 f64  (array String)   String (num.complex f64)     # ok
  f _                                                              #  1. should flag an error: failed to infer type parameter A
  f u8 _                                                           #  2. should flag an error: undefined open type parameter
  f _ u8                                                           #  3. should flag an error: too many value arguments
  f _ _                                                            #  4. should flag an error: too many value arguments
  f             3.14 ["true","false"] "?!?"  (num.complex 3.14 4)  #  5. should flag an error: too many value arguments
  f u8 unit i32 3.14 ["true","false"] "?!?"  (num.complex 3.14 4)  #  6. should flag an error: too many value arguments
  f _           3.14 ["true","false"] "?!?"  (num.complex 3.14 4)  #  7. should flag an error: too many value arguments


  # ------------------------------


  # Add two normal type parameters
  #
  g(T,U type, A type ...) =>
    say "g $T $U $A"

  g u8 unit                                                        # ok
  g u8 unit i32                                                    # ok
  g u8 unit i32 f64                                                # ok
  g u8 unit i32 f64  (array String)   String (num.complex f64)     # ok
  g             3.14 ["true","false"] "?!?"  (num.complex 3.14 4)  #  8. should flag an error: failed to infer type parameter T, U
  g u8 unit i32 3.14 ["true","false"] "?!?"  (num.complex 3.14 4)  #  9. should flag an error: too many value arguments
  g _                                                              # 10. should flag an error: wrong number of arguments
  g _  _                                                           # 11. should flag an error: failed to infer T, U
  g _  _    _                                                      # 12. should flag an error: failed to infer T, U, A
  g _                                                              # 13. should flag an error: too many value arguments
  g u8 _                                                           # 14. should flag an error: too many value arguments
  g u8 unit                                                        # ok
  g u8 unit _                                                      # 15. should flag an error: failed to infer type parameter A


  # ------------------------------

  # Now an open type argument that is used as the type of a value arguemnt.
  #
  # if open type parameters are used as type of value arguments, the types must be inferred:
  #
  h(A type ..., a A...) =>
    say "h $A $a"

  # giving no type parameters is ok:
  h                                                                       # ok.
  h                    3.14                                               # ok.
  h                    3.14 ["true","false"] "?!?"  (num.complex 3.14 4)  # ok.

  # giving `_` as type parameter is ok:
  h _                                                                     # ok.
  h _                  3.14                                               # ok.
  h _                  3.14 ["true","false"] "?!?"  (num.complex 3.14 4)  # ok.

  # but giving types is not ok, the parser cannot tell them apart from calls:
  (h                                                                      # 16. should flag an error: failed to infer open type parameters
     f64                                                                  # 17. should flag an error: cannot call `f64`
     (array String)                                                       # 18. should flag an error: cannot call `array String`
     3.14
     ["true","false"])


  # ------------------------------


  i(T,U type, A type ..., a A...) =>
    say "i $T $U $A $a"

  i nil unit           3.14 ["true","false"] "?!?"  (num.complex 3.14 4)  # 19. should flag an error: failed to infer T, U
  i nil unit _                                                            # ok.
  i nil unit _         3.14                                               # ok.
  i nil unit _         3.14 ["true","false"] "?!?"  (num.complex 3.14 4)  # ok.
  (i nil unit                                                             # 20. should flag an error: failed to infer T, U
     f64                                                                  # 21. should flag an error: cannot call `f64`
     (array String)                                                       # 22. should flag an error: cannot call `array String`
     3.14
     ["true","false"])


  # ------------------------------


  j(T,U type, A type ..., t T, a A...) =>
    say "j $T $U $A $t $a"

  j f64 unit _         3.14                                               # ok.
  j _   unit _         3.14                                               # ok.
  j f64 unit _         3.14 ["true","false"]                              # ok.
  j _   unit _         3.14 ["true","false"]                              # ok.
  j f64 unit _         3.14 ["true","false"] "?!?"  (num.complex 3.14 4)  # ok.
  j _   unit _         3.14 ["true","false"] "?!?"  (num.complex 3.14 4)  # ok.
  j f64 unit           3.14                                               # 23. should flag an error: failed to infer T, U
  j _   unit           3.14                                               # 24. should flag an error: open type must be inferred using `_`
  j f64 unit           3.14 ["true","false"]                              # 25. should flag an error: feature not found `f64`
  j _   unit           3.14 ["true","false"]                              # 26. should flag an error: open type must be inferred using `_`
  j f64 unit           3.14 ["true","false"] "?!?"  (num.complex 3.14 4)  # 27. should flag an error: feature not found `f64`
  j _   unit           3.14 ["true","false"] "?!?"  (num.complex 3.14 4)  # 28. should flag an error: open type must be inferred using `_`


  # ------------------------------


  k(T,U type, A type ..., t T, u U, a A...) =>
    say "k $T $U $A $t $u $a"

  k f64 Any _ 3.14 ["true","false"]                                         # ok.
  k _   Any _ 3.14 ["true","false"]                                         # ok.
  k _   _   _ 3.14 ["true","false"]                                         # ok.
  k f64 Any _ 3.14 ["true","false"] "?!?"                                   # ok.
  k _   Any _ 3.14 ["true","false"] "?!?"                                   # ok.
  k _   _   _ 3.14 ["true","false"] "?!?"                                   # ok.
  k f64 Any _ 3.14 ["true","false"] "?!?"  (num.complex 3.14 4)             # ok.
  k _   Any _ 3.14 ["true","false"] "?!?"  (num.complex 3.14 4)             # ok.
  k _   _   _ 3.14 ["true","false"] "?!?"  (num.complex 3.14 4)             # ok.
  k f64 Any   3.14 ["true","false"]                                         # 29. should flag an error: feature not found `f64`
  k _   Any   3.14 ["true","false"]                                         # 30. should flag an error: open type must be inferred using `_`
  k _   _     3.14 ["true","false"]                                         # 31. should flag an error: open type must be inferred using `_`
  k f64 Any   3.14 ["true","false"] "?!?"                                   # 32. should flag an error: feature not found `f64`
  k _   Any   3.14 ["true","false"] "?!?"                                   # 33. should flag an error: open type must be inferred using `_`
  k _   _     3.14 ["true","false"] "?!?"                                   # 34. should flag an error: open type must be inferred using `_`
  k f64 Any   3.14 ["true","false"] "?!?"  (num.complex 3.14 4)             # 35. should flag an error: feature not found `f64`
  k _   Any   3.14 ["true","false"] "?!?"  (num.complex 3.14 4)             # 36. should flag an error: open type must be inferred using `_`
  k _   _     3.14 ["true","false"] "?!?"  (num.complex 3.14 4)             # 37. should flag an error: open type must be inferred using `_`
